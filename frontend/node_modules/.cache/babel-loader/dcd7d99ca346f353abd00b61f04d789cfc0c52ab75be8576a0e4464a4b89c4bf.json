{"ast":null,"code":"\"use strict\";\n\n/**\n * @license\n * Copyright 2023 Google Inc.\n * SPDX-License-Identifier: Apache-2.0\n */\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports._connectToBiDiBrowser = void 0;\nconst Connection_js_1 = require(\"../cdp/Connection.js\");\nconst Errors_js_1 = require(\"../common/Errors.js\");\nconst util_js_1 = require(\"../common/util.js\");\n/**\n * Users should never call this directly; it's called when calling `puppeteer.connect`\n * with `protocol: 'webDriverBiDi'`. This method attaches Puppeteer to an existing browser\n * instance. First it tries to connect to the browser using pure BiDi. If the protocol is\n * not supported, connects to the browser using BiDi over CDP.\n *\n * @internal\n */\nasync function _connectToBiDiBrowser(connectionTransport, url, options) {\n  const {\n    acceptInsecureCerts = false,\n    defaultViewport = util_js_1.DEFAULT_VIEWPORT\n  } = options;\n  const {\n    bidiConnection,\n    cdpConnection,\n    closeCallback\n  } = await getBiDiConnection(connectionTransport, url, options);\n  const BiDi = await Promise.resolve().then(() => __importStar(require( /* webpackIgnore: true */'./bidi.js')));\n  const bidiBrowser = await BiDi.BidiBrowser.create({\n    connection: bidiConnection,\n    cdpConnection,\n    closeCallback,\n    process: undefined,\n    defaultViewport: defaultViewport,\n    acceptInsecureCerts: acceptInsecureCerts,\n    capabilities: options.capabilities\n  });\n  return bidiBrowser;\n}\nexports._connectToBiDiBrowser = _connectToBiDiBrowser;\n/**\n * Returns a BiDiConnection established to the endpoint specified by the options and a\n * callback closing the browser. Callback depends on whether the connection is pure BiDi\n * or BiDi over CDP.\n * The method tries to connect to the browser using pure BiDi protocol, and falls back\n * to BiDi over CDP.\n */\nasync function getBiDiConnection(connectionTransport, url, options) {\n  const BiDi = await Promise.resolve().then(() => __importStar(require( /* webpackIgnore: true */'./bidi.js')));\n  const {\n    slowMo = 0,\n    protocolTimeout\n  } = options;\n  // Try pure BiDi first.\n  const pureBidiConnection = new BiDi.BidiConnection(url, connectionTransport, slowMo, protocolTimeout);\n  try {\n    const result = await pureBidiConnection.send('session.status', {});\n    if ('type' in result && result.type === 'success') {\n      // The `browserWSEndpoint` points to an endpoint supporting pure WebDriver BiDi.\n      return {\n        bidiConnection: pureBidiConnection,\n        closeCallback: async () => {\n          await pureBidiConnection.send('browser.close', {}).catch(util_js_1.debugError);\n        }\n      };\n    }\n  } catch (e) {\n    if (!(e instanceof Errors_js_1.ProtocolError)) {\n      // Unexpected exception not related to BiDi / CDP. Rethrow.\n      throw e;\n    }\n  }\n  // Unbind the connection to avoid memory leaks.\n  pureBidiConnection.unbind();\n  // Fall back to CDP over BiDi reusing the WS connection.\n  const cdpConnection = new Connection_js_1.Connection(url, connectionTransport, slowMo, protocolTimeout);\n  const version = await cdpConnection.send('Browser.getVersion');\n  if (version.product.toLowerCase().includes('firefox')) {\n    throw new Errors_js_1.UnsupportedOperation('Firefox is not supported in BiDi over CDP mode.');\n  }\n  const bidiOverCdpConnection = await BiDi.connectBidiOverCdp(cdpConnection);\n  return {\n    cdpConnection,\n    bidiConnection: bidiOverCdpConnection,\n    closeCallback: async () => {\n      // In case of BiDi over CDP, we need to close browser via CDP.\n      await cdpConnection.send('Browser.close').catch(util_js_1.debugError);\n    }\n  };\n}","map":{"version":3,"names":["Connection_js_1","require","Errors_js_1","util_js_1","_connectToBiDiBrowser","connectionTransport","url","options","acceptInsecureCerts","defaultViewport","DEFAULT_VIEWPORT","bidiConnection","cdpConnection","closeCallback","getBiDiConnection","BiDi","Promise","resolve","then","__importStar","bidiBrowser","BidiBrowser","create","connection","process","undefined","capabilities","exports","slowMo","protocolTimeout","pureBidiConnection","BidiConnection","result","send","type","catch","debugError","e","ProtocolError","unbind","Connection","version","product","toLowerCase","includes","UnsupportedOperation","bidiOverCdpConnection","connectBidiOverCdp"],"sources":["/Users/lawj4/webDevelopment/Todo-List/frontend/node_modules/puppeteer-core/src/bidi/BrowserConnector.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2023 Google Inc.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport type {BrowserCloseCallback} from '../api/Browser.js';\nimport {Connection} from '../cdp/Connection.js';\nimport type {ConnectionTransport} from '../common/ConnectionTransport.js';\nimport type {\n  BrowserConnectOptions,\n  ConnectOptions,\n} from '../common/ConnectOptions.js';\nimport {ProtocolError, UnsupportedOperation} from '../common/Errors.js';\nimport {debugError, DEFAULT_VIEWPORT} from '../common/util.js';\n\nimport type {BidiBrowser} from './Browser.js';\nimport type {BidiConnection} from './Connection.js';\n\n/**\n * Users should never call this directly; it's called when calling `puppeteer.connect`\n * with `protocol: 'webDriverBiDi'`. This method attaches Puppeteer to an existing browser\n * instance. First it tries to connect to the browser using pure BiDi. If the protocol is\n * not supported, connects to the browser using BiDi over CDP.\n *\n * @internal\n */\nexport async function _connectToBiDiBrowser(\n  connectionTransport: ConnectionTransport,\n  url: string,\n  options: BrowserConnectOptions & ConnectOptions\n): Promise<BidiBrowser> {\n  const {acceptInsecureCerts = false, defaultViewport = DEFAULT_VIEWPORT} =\n    options;\n\n  const {bidiConnection, cdpConnection, closeCallback} =\n    await getBiDiConnection(connectionTransport, url, options);\n  const BiDi = await import(/* webpackIgnore: true */ './bidi.js');\n  const bidiBrowser = await BiDi.BidiBrowser.create({\n    connection: bidiConnection,\n    cdpConnection,\n    closeCallback,\n    process: undefined,\n    defaultViewport: defaultViewport,\n    acceptInsecureCerts: acceptInsecureCerts,\n    capabilities: options.capabilities,\n  });\n  return bidiBrowser;\n}\n\n/**\n * Returns a BiDiConnection established to the endpoint specified by the options and a\n * callback closing the browser. Callback depends on whether the connection is pure BiDi\n * or BiDi over CDP.\n * The method tries to connect to the browser using pure BiDi protocol, and falls back\n * to BiDi over CDP.\n */\nasync function getBiDiConnection(\n  connectionTransport: ConnectionTransport,\n  url: string,\n  options: BrowserConnectOptions\n): Promise<{\n  cdpConnection?: Connection;\n  bidiConnection: BidiConnection;\n  closeCallback: BrowserCloseCallback;\n}> {\n  const BiDi = await import(/* webpackIgnore: true */ './bidi.js');\n  const {slowMo = 0, protocolTimeout} = options;\n\n  // Try pure BiDi first.\n  const pureBidiConnection = new BiDi.BidiConnection(\n    url,\n    connectionTransport,\n    slowMo,\n    protocolTimeout\n  );\n  try {\n    const result = await pureBidiConnection.send('session.status', {});\n    if ('type' in result && result.type === 'success') {\n      // The `browserWSEndpoint` points to an endpoint supporting pure WebDriver BiDi.\n      return {\n        bidiConnection: pureBidiConnection,\n        closeCallback: async () => {\n          await pureBidiConnection.send('browser.close', {}).catch(debugError);\n        },\n      };\n    }\n  } catch (e) {\n    if (!(e instanceof ProtocolError)) {\n      // Unexpected exception not related to BiDi / CDP. Rethrow.\n      throw e;\n    }\n  }\n  // Unbind the connection to avoid memory leaks.\n  pureBidiConnection.unbind();\n\n  // Fall back to CDP over BiDi reusing the WS connection.\n  const cdpConnection = new Connection(\n    url,\n    connectionTransport,\n    slowMo,\n    protocolTimeout\n  );\n\n  const version = await cdpConnection.send('Browser.getVersion');\n  if (version.product.toLowerCase().includes('firefox')) {\n    throw new UnsupportedOperation(\n      'Firefox is not supported in BiDi over CDP mode.'\n    );\n  }\n\n  const bidiOverCdpConnection = await BiDi.connectBidiOverCdp(cdpConnection);\n  return {\n    cdpConnection,\n    bidiConnection: bidiOverCdpConnection,\n    closeCallback: async () => {\n      // In case of BiDi over CDP, we need to close browser via CDP.\n      await cdpConnection.send('Browser.close').catch(debugError);\n    },\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}