{"ast":null,"code":"\"use strict\";\n\n/**\n * @license\n * Copyright 2022 Google Inc.\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ChromeTargetManager = void 0;\nconst CDPSession_js_1 = require(\"../api/CDPSession.js\");\nconst EventEmitter_js_1 = require(\"../common/EventEmitter.js\");\nconst util_js_1 = require(\"../common/util.js\");\nconst assert_js_1 = require(\"../util/assert.js\");\nconst Deferred_js_1 = require(\"../util/Deferred.js\");\nconst Target_js_1 = require(\"./Target.js\");\nfunction isPageTargetBecomingPrimary(target, newTargetInfo) {\n  return Boolean(target._subtype()) && !newTargetInfo.subtype;\n}\n/**\n * ChromeTargetManager uses the CDP's auto-attach mechanism to intercept\n * new targets and allow the rest of Puppeteer to configure listeners while\n * the target is paused.\n *\n * @internal\n */\nclass ChromeTargetManager extends EventEmitter_js_1.EventEmitter {\n  #connection;\n  /**\n   * Keeps track of the following events: 'Target.targetCreated',\n   * 'Target.targetDestroyed', 'Target.targetInfoChanged'.\n   *\n   * A target becomes discovered when 'Target.targetCreated' is received.\n   * A target is removed from this map once 'Target.targetDestroyed' is\n   * received.\n   *\n   * `targetFilterCallback` has no effect on this map.\n   */\n  #discoveredTargetsByTargetId = new Map();\n  /**\n   * A target is added to this map once ChromeTargetManager has created\n   * a Target and attached at least once to it.\n   */\n  #attachedTargetsByTargetId = new Map();\n  /**\n   * Tracks which sessions attach to which target.\n   */\n  #attachedTargetsBySessionId = new Map();\n  /**\n   * If a target was filtered out by `targetFilterCallback`, we still receive\n   * events about it from CDP, but we don't forward them to the rest of Puppeteer.\n   */\n  #ignoredTargets = new Set();\n  #targetFilterCallback;\n  #targetFactory;\n  #attachedToTargetListenersBySession = new WeakMap();\n  #detachedFromTargetListenersBySession = new WeakMap();\n  #initializeDeferred = Deferred_js_1.Deferred.create();\n  #targetsIdsForInit = new Set();\n  #waitForInitiallyDiscoveredTargets = true;\n  #discoveryFilter = [{}];\n  constructor(connection, targetFactory, targetFilterCallback, waitForInitiallyDiscoveredTargets = true) {\n    super();\n    this.#connection = connection;\n    this.#targetFilterCallback = targetFilterCallback;\n    this.#targetFactory = targetFactory;\n    this.#waitForInitiallyDiscoveredTargets = waitForInitiallyDiscoveredTargets;\n    this.#connection.on('Target.targetCreated', this.#onTargetCreated);\n    this.#connection.on('Target.targetDestroyed', this.#onTargetDestroyed);\n    this.#connection.on('Target.targetInfoChanged', this.#onTargetInfoChanged);\n    this.#connection.on(CDPSession_js_1.CDPSessionEvent.SessionDetached, this.#onSessionDetached);\n    this.#setupAttachmentListeners(this.#connection);\n  }\n  #storeExistingTargetsForInit = () => {\n    if (!this.#waitForInitiallyDiscoveredTargets) {\n      return;\n    }\n    for (const [targetId, targetInfo] of this.#discoveredTargetsByTargetId.entries()) {\n      const targetForFilter = new Target_js_1.CdpTarget(targetInfo, undefined, undefined, this, undefined);\n      // Only wait for pages and frames (except those from extensions)\n      // to auto-attach.\n      const isPageOrFrame = targetInfo.type === 'page' || targetInfo.type === 'iframe';\n      const isExtension = targetInfo.url.startsWith('chrome-extension://');\n      if ((!this.#targetFilterCallback || this.#targetFilterCallback(targetForFilter)) && isPageOrFrame && !isExtension) {\n        this.#targetsIdsForInit.add(targetId);\n      }\n    }\n  };\n  async initialize() {\n    await this.#connection.send('Target.setDiscoverTargets', {\n      discover: true,\n      filter: this.#discoveryFilter\n    });\n    this.#storeExistingTargetsForInit();\n    await this.#connection.send('Target.setAutoAttach', {\n      waitForDebuggerOnStart: true,\n      flatten: true,\n      autoAttach: true,\n      filter: [{\n        type: 'page',\n        exclude: true\n      }, ...this.#discoveryFilter]\n    });\n    this.#finishInitializationIfReady();\n    await this.#initializeDeferred.valueOrThrow();\n  }\n  getChildTargets(target) {\n    return target._childTargets();\n  }\n  dispose() {\n    this.#connection.off('Target.targetCreated', this.#onTargetCreated);\n    this.#connection.off('Target.targetDestroyed', this.#onTargetDestroyed);\n    this.#connection.off('Target.targetInfoChanged', this.#onTargetInfoChanged);\n    this.#connection.off(CDPSession_js_1.CDPSessionEvent.SessionDetached, this.#onSessionDetached);\n    this.#removeAttachmentListeners(this.#connection);\n  }\n  getAvailableTargets() {\n    return this.#attachedTargetsByTargetId;\n  }\n  #setupAttachmentListeners(session) {\n    const listener = event => {\n      void this.#onAttachedToTarget(session, event);\n    };\n    (0, assert_js_1.assert)(!this.#attachedToTargetListenersBySession.has(session));\n    this.#attachedToTargetListenersBySession.set(session, listener);\n    session.on('Target.attachedToTarget', listener);\n    const detachedListener = event => {\n      return this.#onDetachedFromTarget(session, event);\n    };\n    (0, assert_js_1.assert)(!this.#detachedFromTargetListenersBySession.has(session));\n    this.#detachedFromTargetListenersBySession.set(session, detachedListener);\n    session.on('Target.detachedFromTarget', detachedListener);\n  }\n  #removeAttachmentListeners(session) {\n    const listener = this.#attachedToTargetListenersBySession.get(session);\n    if (listener) {\n      session.off('Target.attachedToTarget', listener);\n      this.#attachedToTargetListenersBySession.delete(session);\n    }\n    if (this.#detachedFromTargetListenersBySession.has(session)) {\n      session.off('Target.detachedFromTarget', this.#detachedFromTargetListenersBySession.get(session));\n      this.#detachedFromTargetListenersBySession.delete(session);\n    }\n  }\n  #onSessionDetached = session => {\n    this.#removeAttachmentListeners(session);\n  };\n  #onTargetCreated = async event => {\n    this.#discoveredTargetsByTargetId.set(event.targetInfo.targetId, event.targetInfo);\n    this.emit(\"targetDiscovered\" /* TargetManagerEvent.TargetDiscovered */, event.targetInfo);\n    // The connection is already attached to the browser target implicitly,\n    // therefore, no new CDPSession is created and we have special handling\n    // here.\n    if (event.targetInfo.type === 'browser' && event.targetInfo.attached) {\n      if (this.#attachedTargetsByTargetId.has(event.targetInfo.targetId)) {\n        return;\n      }\n      const target = this.#targetFactory(event.targetInfo, undefined);\n      target._initialize();\n      this.#attachedTargetsByTargetId.set(event.targetInfo.targetId, target);\n    }\n  };\n  #onTargetDestroyed = event => {\n    const targetInfo = this.#discoveredTargetsByTargetId.get(event.targetId);\n    this.#discoveredTargetsByTargetId.delete(event.targetId);\n    this.#finishInitializationIfReady(event.targetId);\n    if (targetInfo?.type === 'service_worker' && this.#attachedTargetsByTargetId.has(event.targetId)) {\n      // Special case for service workers: report TargetGone event when\n      // the worker is destroyed.\n      const target = this.#attachedTargetsByTargetId.get(event.targetId);\n      if (target) {\n        this.emit(\"targetGone\" /* TargetManagerEvent.TargetGone */, target);\n        this.#attachedTargetsByTargetId.delete(event.targetId);\n      }\n    }\n  };\n  #onTargetInfoChanged = event => {\n    this.#discoveredTargetsByTargetId.set(event.targetInfo.targetId, event.targetInfo);\n    if (this.#ignoredTargets.has(event.targetInfo.targetId) || !this.#attachedTargetsByTargetId.has(event.targetInfo.targetId) || !event.targetInfo.attached) {\n      return;\n    }\n    const target = this.#attachedTargetsByTargetId.get(event.targetInfo.targetId);\n    if (!target) {\n      return;\n    }\n    const previousURL = target.url();\n    const wasInitialized = target._initializedDeferred.value() === Target_js_1.InitializationStatus.SUCCESS;\n    if (isPageTargetBecomingPrimary(target, event.targetInfo)) {\n      const session = target?._session();\n      (0, assert_js_1.assert)(session, 'Target that is being activated is missing a CDPSession.');\n      session.parentSession()?.emit(CDPSession_js_1.CDPSessionEvent.Swapped, session);\n    }\n    target._targetInfoChanged(event.targetInfo);\n    if (wasInitialized && previousURL !== target.url()) {\n      this.emit(\"targetChanged\" /* TargetManagerEvent.TargetChanged */, {\n        target,\n        wasInitialized,\n        previousURL\n      });\n    }\n  };\n  #onAttachedToTarget = async (parentSession, event) => {\n    const targetInfo = event.targetInfo;\n    const session = this.#connection.session(event.sessionId);\n    if (!session) {\n      throw new Error(`Session ${event.sessionId} was not created.`);\n    }\n    const silentDetach = async () => {\n      await session.send('Runtime.runIfWaitingForDebugger').catch(util_js_1.debugError);\n      // We don't use `session.detach()` because that dispatches all commands on\n      // the connection instead of the parent session.\n      await parentSession.send('Target.detachFromTarget', {\n        sessionId: session.id()\n      }).catch(util_js_1.debugError);\n    };\n    if (!this.#connection.isAutoAttached(targetInfo.targetId)) {\n      return;\n    }\n    // Special case for service workers: being attached to service workers will\n    // prevent them from ever being destroyed. Therefore, we silently detach\n    // from service workers unless the connection was manually created via\n    // `page.worker()`. To determine this, we use\n    // `this.#connection.isAutoAttached(targetInfo.targetId)`. In the future, we\n    // should determine if a target is auto-attached or not with the help of\n    // CDP.\n    if (targetInfo.type === 'service_worker') {\n      this.#finishInitializationIfReady(targetInfo.targetId);\n      await silentDetach();\n      if (this.#attachedTargetsByTargetId.has(targetInfo.targetId)) {\n        return;\n      }\n      const target = this.#targetFactory(targetInfo);\n      target._initialize();\n      this.#attachedTargetsByTargetId.set(targetInfo.targetId, target);\n      this.emit(\"targetAvailable\" /* TargetManagerEvent.TargetAvailable */, target);\n      return;\n    }\n    const isExistingTarget = this.#attachedTargetsByTargetId.has(targetInfo.targetId);\n    const target = isExistingTarget ? this.#attachedTargetsByTargetId.get(targetInfo.targetId) : this.#targetFactory(targetInfo, session, parentSession instanceof CDPSession_js_1.CDPSession ? parentSession : undefined);\n    if (this.#targetFilterCallback && !this.#targetFilterCallback(target)) {\n      this.#ignoredTargets.add(targetInfo.targetId);\n      this.#finishInitializationIfReady(targetInfo.targetId);\n      await silentDetach();\n      return;\n    }\n    this.#setupAttachmentListeners(session);\n    if (isExistingTarget) {\n      session._setTarget(target);\n      this.#attachedTargetsBySessionId.set(session.id(), this.#attachedTargetsByTargetId.get(targetInfo.targetId));\n    } else {\n      target._initialize();\n      this.#attachedTargetsByTargetId.set(targetInfo.targetId, target);\n      this.#attachedTargetsBySessionId.set(session.id(), target);\n    }\n    const parentTarget = parentSession instanceof CDPSession_js_1.CDPSession ? parentSession._target() : null;\n    parentTarget?._addChildTarget(target);\n    parentSession.emit(CDPSession_js_1.CDPSessionEvent.Ready, session);\n    this.#targetsIdsForInit.delete(target._targetId);\n    if (!isExistingTarget) {\n      this.emit(\"targetAvailable\" /* TargetManagerEvent.TargetAvailable */, target);\n    }\n    this.#finishInitializationIfReady();\n    // TODO: the browser might be shutting down here. What do we do with the\n    // error?\n    await Promise.all([session.send('Target.setAutoAttach', {\n      waitForDebuggerOnStart: true,\n      flatten: true,\n      autoAttach: true,\n      filter: this.#discoveryFilter\n    }), session.send('Runtime.runIfWaitingForDebugger')]).catch(util_js_1.debugError);\n  };\n  #finishInitializationIfReady(targetId) {\n    targetId !== undefined && this.#targetsIdsForInit.delete(targetId);\n    if (this.#targetsIdsForInit.size === 0) {\n      this.#initializeDeferred.resolve();\n    }\n  }\n  #onDetachedFromTarget = (parentSession, event) => {\n    const target = this.#attachedTargetsBySessionId.get(event.sessionId);\n    this.#attachedTargetsBySessionId.delete(event.sessionId);\n    if (!target) {\n      return;\n    }\n    if (parentSession instanceof CDPSession_js_1.CDPSession) {\n      parentSession._target()._removeChildTarget(target);\n    }\n    this.#attachedTargetsByTargetId.delete(target._targetId);\n    this.emit(\"targetGone\" /* TargetManagerEvent.TargetGone */, target);\n  };\n}\nexports.ChromeTargetManager = ChromeTargetManager;","map":{"version":3,"names":["CDPSession_js_1","require","EventEmitter_js_1","util_js_1","assert_js_1","Deferred_js_1","Target_js_1","isPageTargetBecomingPrimary","target","newTargetInfo","Boolean","_subtype","subtype","ChromeTargetManager","EventEmitter","connection","discoveredTargetsByTargetId","Map","attachedTargetsByTargetId","attachedTargetsBySessionId","ignoredTargets","Set","targetFilterCallback","targetFactory","attachedToTargetListenersBySession","WeakMap","detachedFromTargetListenersBySession","initializeDeferred","Deferred","create","targetsIdsForInit","waitForInitiallyDiscoveredTargets","discoveryFilter","constructor","on","onTargetCreated","onTargetDestroyed","onTargetInfoChanged","CDPSessionEvent","SessionDetached","onSessionDetached","setupAttachmentListeners","storeExistingTargetsForInit","#storeExistingTargetsForInit","targetId","targetInfo","entries","targetForFilter","CdpTarget","undefined","isPageOrFrame","type","isExtension","url","startsWith","add","initialize","send","discover","filter","waitForDebuggerOnStart","flatten","autoAttach","exclude","finishInitializationIfReady","valueOrThrow","getChildTargets","_childTargets","dispose","off","removeAttachmentListeners","getAvailableTargets","#setupAttachmentListeners","session","listener","event","onAttachedToTarget","assert","has","set","detachedListener","onDetachedFromTarget","#removeAttachmentListeners","get","delete","emit","attached","_initialize","previousURL","wasInitialized","_initializedDeferred","value","InitializationStatus","SUCCESS","_session","parentSession","Swapped","_targetInfoChanged","#onAttachedToTarget","sessionId","Error","silentDetach","catch","debugError","id","isAutoAttached","isExistingTarget","CDPSession","_setTarget","parentTarget","_target","_addChildTarget","Ready","_targetId","Promise","all","#finishInitializationIfReady","size","resolve","#onDetachedFromTarget","_removeChildTarget","exports"],"sources":["/Users/lawj4/webDevelopment/node_modules/puppeteer-core/src/cdp/ChromeTargetManager.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2022 Google Inc.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport type {Protocol} from 'devtools-protocol';\n\nimport type {TargetFilterCallback} from '../api/Browser.js';\nimport {CDPSession, CDPSessionEvent} from '../api/CDPSession.js';\nimport {EventEmitter} from '../common/EventEmitter.js';\nimport {debugError} from '../common/util.js';\nimport {assert} from '../util/assert.js';\nimport {Deferred} from '../util/Deferred.js';\n\nimport type {CdpCDPSession} from './CDPSession.js';\nimport type {Connection} from './Connection.js';\nimport {CdpTarget, InitializationStatus} from './Target.js';\nimport {\n  type TargetFactory,\n  type TargetManager,\n  TargetManagerEvent,\n  type TargetManagerEvents,\n} from './TargetManager.js';\n\nfunction isPageTargetBecomingPrimary(\n  target: CdpTarget,\n  newTargetInfo: Protocol.Target.TargetInfo\n): boolean {\n  return Boolean(target._subtype()) && !newTargetInfo.subtype;\n}\n\n/**\n * ChromeTargetManager uses the CDP's auto-attach mechanism to intercept\n * new targets and allow the rest of Puppeteer to configure listeners while\n * the target is paused.\n *\n * @internal\n */\nexport class ChromeTargetManager\n  extends EventEmitter<TargetManagerEvents>\n  implements TargetManager\n{\n  #connection: Connection;\n  /**\n   * Keeps track of the following events: 'Target.targetCreated',\n   * 'Target.targetDestroyed', 'Target.targetInfoChanged'.\n   *\n   * A target becomes discovered when 'Target.targetCreated' is received.\n   * A target is removed from this map once 'Target.targetDestroyed' is\n   * received.\n   *\n   * `targetFilterCallback` has no effect on this map.\n   */\n  #discoveredTargetsByTargetId = new Map<string, Protocol.Target.TargetInfo>();\n  /**\n   * A target is added to this map once ChromeTargetManager has created\n   * a Target and attached at least once to it.\n   */\n  #attachedTargetsByTargetId = new Map<string, CdpTarget>();\n  /**\n   * Tracks which sessions attach to which target.\n   */\n  #attachedTargetsBySessionId = new Map<string, CdpTarget>();\n  /**\n   * If a target was filtered out by `targetFilterCallback`, we still receive\n   * events about it from CDP, but we don't forward them to the rest of Puppeteer.\n   */\n  #ignoredTargets = new Set<string>();\n  #targetFilterCallback: TargetFilterCallback | undefined;\n  #targetFactory: TargetFactory;\n\n  #attachedToTargetListenersBySession = new WeakMap<\n    CDPSession | Connection,\n    (event: Protocol.Target.AttachedToTargetEvent) => void\n  >();\n  #detachedFromTargetListenersBySession = new WeakMap<\n    CDPSession | Connection,\n    (event: Protocol.Target.DetachedFromTargetEvent) => void\n  >();\n\n  #initializeDeferred = Deferred.create<void>();\n  #targetsIdsForInit = new Set<string>();\n  #waitForInitiallyDiscoveredTargets = true;\n\n  #discoveryFilter: Protocol.Target.FilterEntry[] = [{}];\n\n  constructor(\n    connection: Connection,\n    targetFactory: TargetFactory,\n    targetFilterCallback?: TargetFilterCallback,\n    waitForInitiallyDiscoveredTargets = true\n  ) {\n    super();\n    this.#connection = connection;\n    this.#targetFilterCallback = targetFilterCallback;\n    this.#targetFactory = targetFactory;\n    this.#waitForInitiallyDiscoveredTargets = waitForInitiallyDiscoveredTargets;\n\n    this.#connection.on('Target.targetCreated', this.#onTargetCreated);\n    this.#connection.on('Target.targetDestroyed', this.#onTargetDestroyed);\n    this.#connection.on('Target.targetInfoChanged', this.#onTargetInfoChanged);\n    this.#connection.on(\n      CDPSessionEvent.SessionDetached,\n      this.#onSessionDetached\n    );\n    this.#setupAttachmentListeners(this.#connection);\n  }\n\n  #storeExistingTargetsForInit = () => {\n    if (!this.#waitForInitiallyDiscoveredTargets) {\n      return;\n    }\n    for (const [\n      targetId,\n      targetInfo,\n    ] of this.#discoveredTargetsByTargetId.entries()) {\n      const targetForFilter = new CdpTarget(\n        targetInfo,\n        undefined,\n        undefined,\n        this,\n        undefined\n      );\n      // Only wait for pages and frames (except those from extensions)\n      // to auto-attach.\n      const isPageOrFrame =\n        targetInfo.type === 'page' || targetInfo.type === 'iframe';\n      const isExtension = targetInfo.url.startsWith('chrome-extension://');\n      if (\n        (!this.#targetFilterCallback ||\n          this.#targetFilterCallback(targetForFilter)) &&\n        isPageOrFrame &&\n        !isExtension\n      ) {\n        this.#targetsIdsForInit.add(targetId);\n      }\n    }\n  };\n\n  async initialize(): Promise<void> {\n    await this.#connection.send('Target.setDiscoverTargets', {\n      discover: true,\n      filter: this.#discoveryFilter,\n    });\n\n    this.#storeExistingTargetsForInit();\n\n    await this.#connection.send('Target.setAutoAttach', {\n      waitForDebuggerOnStart: true,\n      flatten: true,\n      autoAttach: true,\n      filter: [\n        {\n          type: 'page',\n          exclude: true,\n        },\n        ...this.#discoveryFilter,\n      ],\n    });\n    this.#finishInitializationIfReady();\n    await this.#initializeDeferred.valueOrThrow();\n  }\n\n  getChildTargets(target: CdpTarget): ReadonlySet<CdpTarget> {\n    return target._childTargets();\n  }\n\n  dispose(): void {\n    this.#connection.off('Target.targetCreated', this.#onTargetCreated);\n    this.#connection.off('Target.targetDestroyed', this.#onTargetDestroyed);\n    this.#connection.off('Target.targetInfoChanged', this.#onTargetInfoChanged);\n    this.#connection.off(\n      CDPSessionEvent.SessionDetached,\n      this.#onSessionDetached\n    );\n\n    this.#removeAttachmentListeners(this.#connection);\n  }\n\n  getAvailableTargets(): ReadonlyMap<string, CdpTarget> {\n    return this.#attachedTargetsByTargetId;\n  }\n\n  #setupAttachmentListeners(session: CDPSession | Connection): void {\n    const listener = (event: Protocol.Target.AttachedToTargetEvent) => {\n      void this.#onAttachedToTarget(session, event);\n    };\n    assert(!this.#attachedToTargetListenersBySession.has(session));\n    this.#attachedToTargetListenersBySession.set(session, listener);\n    session.on('Target.attachedToTarget', listener);\n\n    const detachedListener = (\n      event: Protocol.Target.DetachedFromTargetEvent\n    ) => {\n      return this.#onDetachedFromTarget(session, event);\n    };\n    assert(!this.#detachedFromTargetListenersBySession.has(session));\n    this.#detachedFromTargetListenersBySession.set(session, detachedListener);\n    session.on('Target.detachedFromTarget', detachedListener);\n  }\n\n  #removeAttachmentListeners(session: CDPSession | Connection): void {\n    const listener = this.#attachedToTargetListenersBySession.get(session);\n    if (listener) {\n      session.off('Target.attachedToTarget', listener);\n      this.#attachedToTargetListenersBySession.delete(session);\n    }\n\n    if (this.#detachedFromTargetListenersBySession.has(session)) {\n      session.off(\n        'Target.detachedFromTarget',\n        this.#detachedFromTargetListenersBySession.get(session)!\n      );\n      this.#detachedFromTargetListenersBySession.delete(session);\n    }\n  }\n\n  #onSessionDetached = (session: CDPSession) => {\n    this.#removeAttachmentListeners(session);\n  };\n\n  #onTargetCreated = async (event: Protocol.Target.TargetCreatedEvent) => {\n    this.#discoveredTargetsByTargetId.set(\n      event.targetInfo.targetId,\n      event.targetInfo\n    );\n\n    this.emit(TargetManagerEvent.TargetDiscovered, event.targetInfo);\n\n    // The connection is already attached to the browser target implicitly,\n    // therefore, no new CDPSession is created and we have special handling\n    // here.\n    if (event.targetInfo.type === 'browser' && event.targetInfo.attached) {\n      if (this.#attachedTargetsByTargetId.has(event.targetInfo.targetId)) {\n        return;\n      }\n      const target = this.#targetFactory(event.targetInfo, undefined);\n      target._initialize();\n      this.#attachedTargetsByTargetId.set(event.targetInfo.targetId, target);\n    }\n  };\n\n  #onTargetDestroyed = (event: Protocol.Target.TargetDestroyedEvent) => {\n    const targetInfo = this.#discoveredTargetsByTargetId.get(event.targetId);\n    this.#discoveredTargetsByTargetId.delete(event.targetId);\n    this.#finishInitializationIfReady(event.targetId);\n    if (\n      targetInfo?.type === 'service_worker' &&\n      this.#attachedTargetsByTargetId.has(event.targetId)\n    ) {\n      // Special case for service workers: report TargetGone event when\n      // the worker is destroyed.\n      const target = this.#attachedTargetsByTargetId.get(event.targetId);\n      if (target) {\n        this.emit(TargetManagerEvent.TargetGone, target);\n        this.#attachedTargetsByTargetId.delete(event.targetId);\n      }\n    }\n  };\n\n  #onTargetInfoChanged = (event: Protocol.Target.TargetInfoChangedEvent) => {\n    this.#discoveredTargetsByTargetId.set(\n      event.targetInfo.targetId,\n      event.targetInfo\n    );\n\n    if (\n      this.#ignoredTargets.has(event.targetInfo.targetId) ||\n      !this.#attachedTargetsByTargetId.has(event.targetInfo.targetId) ||\n      !event.targetInfo.attached\n    ) {\n      return;\n    }\n\n    const target = this.#attachedTargetsByTargetId.get(\n      event.targetInfo.targetId\n    );\n    if (!target) {\n      return;\n    }\n    const previousURL = target.url();\n    const wasInitialized =\n      target._initializedDeferred.value() === InitializationStatus.SUCCESS;\n\n    if (isPageTargetBecomingPrimary(target, event.targetInfo)) {\n      const session = target?._session();\n      assert(\n        session,\n        'Target that is being activated is missing a CDPSession.'\n      );\n      session.parentSession()?.emit(CDPSessionEvent.Swapped, session);\n    }\n\n    target._targetInfoChanged(event.targetInfo);\n\n    if (wasInitialized && previousURL !== target.url()) {\n      this.emit(TargetManagerEvent.TargetChanged, {\n        target,\n        wasInitialized,\n        previousURL,\n      });\n    }\n  };\n\n  #onAttachedToTarget = async (\n    parentSession: Connection | CDPSession,\n    event: Protocol.Target.AttachedToTargetEvent\n  ) => {\n    const targetInfo = event.targetInfo;\n    const session = this.#connection.session(event.sessionId);\n    if (!session) {\n      throw new Error(`Session ${event.sessionId} was not created.`);\n    }\n\n    const silentDetach = async () => {\n      await session.send('Runtime.runIfWaitingForDebugger').catch(debugError);\n      // We don't use `session.detach()` because that dispatches all commands on\n      // the connection instead of the parent session.\n      await parentSession\n        .send('Target.detachFromTarget', {\n          sessionId: session.id(),\n        })\n        .catch(debugError);\n    };\n\n    if (!this.#connection.isAutoAttached(targetInfo.targetId)) {\n      return;\n    }\n\n    // Special case for service workers: being attached to service workers will\n    // prevent them from ever being destroyed. Therefore, we silently detach\n    // from service workers unless the connection was manually created via\n    // `page.worker()`. To determine this, we use\n    // `this.#connection.isAutoAttached(targetInfo.targetId)`. In the future, we\n    // should determine if a target is auto-attached or not with the help of\n    // CDP.\n    if (targetInfo.type === 'service_worker') {\n      this.#finishInitializationIfReady(targetInfo.targetId);\n      await silentDetach();\n      if (this.#attachedTargetsByTargetId.has(targetInfo.targetId)) {\n        return;\n      }\n      const target = this.#targetFactory(targetInfo);\n      target._initialize();\n      this.#attachedTargetsByTargetId.set(targetInfo.targetId, target);\n      this.emit(TargetManagerEvent.TargetAvailable, target);\n      return;\n    }\n\n    const isExistingTarget = this.#attachedTargetsByTargetId.has(\n      targetInfo.targetId\n    );\n\n    const target = isExistingTarget\n      ? this.#attachedTargetsByTargetId.get(targetInfo.targetId)!\n      : this.#targetFactory(\n          targetInfo,\n          session,\n          parentSession instanceof CDPSession ? parentSession : undefined\n        );\n\n    if (this.#targetFilterCallback && !this.#targetFilterCallback(target)) {\n      this.#ignoredTargets.add(targetInfo.targetId);\n      this.#finishInitializationIfReady(targetInfo.targetId);\n      await silentDetach();\n      return;\n    }\n\n    this.#setupAttachmentListeners(session);\n\n    if (isExistingTarget) {\n      (session as CdpCDPSession)._setTarget(target);\n      this.#attachedTargetsBySessionId.set(\n        session.id(),\n        this.#attachedTargetsByTargetId.get(targetInfo.targetId)!\n      );\n    } else {\n      target._initialize();\n      this.#attachedTargetsByTargetId.set(targetInfo.targetId, target);\n      this.#attachedTargetsBySessionId.set(session.id(), target);\n    }\n\n    const parentTarget =\n      parentSession instanceof CDPSession\n        ? (parentSession as CdpCDPSession)._target()\n        : null;\n    parentTarget?._addChildTarget(target);\n\n    parentSession.emit(CDPSessionEvent.Ready, session);\n\n    this.#targetsIdsForInit.delete(target._targetId);\n    if (!isExistingTarget) {\n      this.emit(TargetManagerEvent.TargetAvailable, target);\n    }\n    this.#finishInitializationIfReady();\n\n    // TODO: the browser might be shutting down here. What do we do with the\n    // error?\n    await Promise.all([\n      session.send('Target.setAutoAttach', {\n        waitForDebuggerOnStart: true,\n        flatten: true,\n        autoAttach: true,\n        filter: this.#discoveryFilter,\n      }),\n      session.send('Runtime.runIfWaitingForDebugger'),\n    ]).catch(debugError);\n  };\n\n  #finishInitializationIfReady(targetId?: string): void {\n    targetId !== undefined && this.#targetsIdsForInit.delete(targetId);\n    if (this.#targetsIdsForInit.size === 0) {\n      this.#initializeDeferred.resolve();\n    }\n  }\n\n  #onDetachedFromTarget = (\n    parentSession: Connection | CDPSession,\n    event: Protocol.Target.DetachedFromTargetEvent\n  ) => {\n    const target = this.#attachedTargetsBySessionId.get(event.sessionId);\n\n    this.#attachedTargetsBySessionId.delete(event.sessionId);\n\n    if (!target) {\n      return;\n    }\n\n    if (parentSession instanceof CDPSession) {\n      (parentSession as CdpCDPSession)._target()._removeChildTarget(target);\n    }\n    this.#attachedTargetsByTargetId.delete(target._targetId);\n    this.emit(TargetManagerEvent.TargetGone, target);\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}