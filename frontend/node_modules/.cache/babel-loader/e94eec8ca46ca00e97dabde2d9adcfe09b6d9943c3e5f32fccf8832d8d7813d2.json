{"ast":null,"code":"\"use strict\";\n\n/**\n * Copyright 2023 Google LLC.\n * Copyright (c) Microsoft Corporation.\n * Copyright 2022 The Chromium Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Mutex = void 0;\n/**\n * Use Mutex class to coordinate local concurrent operations.\n * Once `acquire` promise resolves, you hold the lock and must\n * call `release` function returned by `acquire` to release the\n * lock. Failing to `release` the lock may lead to deadlocks.\n */\nclass Mutex {\n  #locked = false;\n  #acquirers = [];\n  // This is FIFO.\n  acquire() {\n    const state = {\n      resolved: false\n    };\n    if (this.#locked) {\n      return new Promise(resolve => {\n        this.#acquirers.push(() => resolve(this.#release.bind(this, state)));\n      });\n    }\n    this.#locked = true;\n    return Promise.resolve(this.#release.bind(this, state));\n  }\n  #release(state) {\n    if (state.resolved) {\n      throw new Error('Cannot release more than once.');\n    }\n    state.resolved = true;\n    const resolve = this.#acquirers.shift();\n    if (!resolve) {\n      this.#locked = false;\n      return;\n    }\n    resolve();\n  }\n  async run(action) {\n    const release = await this.acquire();\n    try {\n      // Note we need to await here because we want the await to release AFTER\n      // that await happens. Returning action() will trigger the release\n      // immediately which is counter to what we want.\n      const result = await action();\n      return result;\n    } finally {\n      release();\n    }\n  }\n}\nexports.Mutex = Mutex;","map":{"version":3,"names":["Mutex","locked","acquirers","acquire","state","resolved","Promise","resolve","push","release","bind","#release","Error","shift","run","action","result","exports"],"sources":["../../../src/utils/Mutex.ts"],"sourcesContent":[null],"mappings":";;AAAA;;;;;;;;;;;;;;;;;;;;;AAoBA;;;;;;AAMA,MAAaA,KAAK;EAChB,CAAAC,MAAO,GAAG,KAAK;EACf,CAAAC,SAAU,GAAmB,EAAE;EAE/B;EACAC,OAAOA,CAAA;IACL,MAAMC,KAAK,GAAG;MAACC,QAAQ,EAAE;IAAK,CAAC;IAC/B,IAAI,IAAI,CAAC,CAAAJ,MAAO,EAAE;MAChB,OAAO,IAAIK,OAAO,CAAEC,OAAO,IAAI;QAC7B,IAAI,CAAC,CAAAL,SAAU,CAACM,IAAI,CAAC,MAAMD,OAAO,CAAC,IAAI,CAAC,CAAAE,OAAQ,CAACC,IAAI,CAAC,IAAI,EAAEN,KAAK,CAAC,CAAC,CAAC;MACtE,CAAC,CAAC;IACJ;IACA,IAAI,CAAC,CAAAH,MAAO,GAAG,IAAI;IACnB,OAAOK,OAAO,CAACC,OAAO,CAAC,IAAI,CAAC,CAAAE,OAAQ,CAACC,IAAI,CAAC,IAAI,EAAEN,KAAK,CAAC,CAAC;EACzD;EAEA,CAAAK,OAAQE,CAACP,KAA0B;IACjC,IAAIA,KAAK,CAACC,QAAQ,EAAE;MAClB,MAAM,IAAIO,KAAK,CAAC,gCAAgC,CAAC;IACnD;IACAR,KAAK,CAACC,QAAQ,GAAG,IAAI;IAErB,MAAME,OAAO,GAAG,IAAI,CAAC,CAAAL,SAAU,CAACW,KAAK,EAAE;IACvC,IAAI,CAACN,OAAO,EAAE;MACZ,IAAI,CAAC,CAAAN,MAAO,GAAG,KAAK;MACpB;IACF;IACAM,OAAO,EAAE;EACX;EAEA,MAAMO,GAAGA,CAAIC,MAAwB;IACnC,MAAMN,OAAO,GAAG,MAAM,IAAI,CAACN,OAAO,EAAE;IACpC,IAAI;MACF;MACA;MACA;MACA,MAAMa,MAAM,GAAG,MAAMD,MAAM,EAAE;MAC7B,OAAOC,MAAM;IACf,CAAC,SAAS;MACRP,OAAO,EAAE;IACX;EACF;;AAzCFQ,OAAA,CAAAjB,KAAA,GAAAA,KAAA","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}