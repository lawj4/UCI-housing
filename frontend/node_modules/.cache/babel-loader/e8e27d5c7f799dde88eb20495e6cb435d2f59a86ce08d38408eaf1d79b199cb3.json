{"ast":null,"code":"\"use strict\";\n\n/**\n * @license\n * Copyright 2017 Google Inc.\n * SPDX-License-Identifier: Apache-2.0\n */\nvar __addDisposableResource = this && this.__addDisposableResource || function (env, value, async) {\n  if (value !== null && value !== void 0) {\n    if (typeof value !== \"object\" && typeof value !== \"function\") throw new TypeError(\"Object expected.\");\n    var dispose;\n    if (async) {\n      if (!Symbol.asyncDispose) throw new TypeError(\"Symbol.asyncDispose is not defined.\");\n      dispose = value[Symbol.asyncDispose];\n    }\n    if (dispose === void 0) {\n      if (!Symbol.dispose) throw new TypeError(\"Symbol.dispose is not defined.\");\n      dispose = value[Symbol.dispose];\n    }\n    if (typeof dispose !== \"function\") throw new TypeError(\"Object not disposable.\");\n    env.stack.push({\n      value: value,\n      dispose: dispose,\n      async: async\n    });\n  } else if (async) {\n    env.stack.push({\n      async: true\n    });\n  }\n  return value;\n};\nvar __disposeResources = this && this.__disposeResources || function (SuppressedError) {\n  return function (env) {\n    function fail(e) {\n      env.error = env.hasError ? new SuppressedError(e, env.error, \"An error was suppressed during disposal.\") : e;\n      env.hasError = true;\n    }\n    function next() {\n      while (env.stack.length) {\n        var rec = env.stack.pop();\n        try {\n          var result = rec.dispose && rec.dispose.call(rec.value);\n          if (rec.async) return Promise.resolve(result).then(next, function (e) {\n            fail(e);\n            return next();\n          });\n        } catch (e) {\n          fail(e);\n        }\n      }\n      if (env.hasError) throw env.error;\n    }\n    return next();\n  };\n}(typeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\n  var e = new Error(message);\n  return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\n});\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ExecutionContext = void 0;\nconst CDPSession_js_1 = require(\"../api/CDPSession.js\");\nconst EventEmitter_js_1 = require(\"../common/EventEmitter.js\");\nconst LazyArg_js_1 = require(\"../common/LazyArg.js\");\nconst ScriptInjector_js_1 = require(\"../common/ScriptInjector.js\");\nconst util_js_1 = require(\"../common/util.js\");\nconst AsyncIterableUtil_js_1 = require(\"../util/AsyncIterableUtil.js\");\nconst disposable_js_1 = require(\"../util/disposable.js\");\nconst Function_js_1 = require(\"../util/Function.js\");\nconst Mutex_js_1 = require(\"../util/Mutex.js\");\nconst AriaQueryHandler_js_1 = require(\"./AriaQueryHandler.js\");\nconst Binding_js_1 = require(\"./Binding.js\");\nconst ElementHandle_js_1 = require(\"./ElementHandle.js\");\nconst JSHandle_js_1 = require(\"./JSHandle.js\");\nconst utils_js_1 = require(\"./utils.js\");\nconst ariaQuerySelectorBinding = new Binding_js_1.Binding('__ariaQuerySelector', AriaQueryHandler_js_1.ARIAQueryHandler.queryOne, '' // custom init\n);\nconst ariaQuerySelectorAllBinding = new Binding_js_1.Binding('__ariaQuerySelectorAll', async (element, selector) => {\n  const results = AriaQueryHandler_js_1.ARIAQueryHandler.queryAll(element, selector);\n  return await element.realm.evaluateHandle((...elements) => {\n    return elements;\n  }, ...(await AsyncIterableUtil_js_1.AsyncIterableUtil.collect(results)));\n}, '' // custom init\n);\n/**\n * @internal\n */\nclass ExecutionContext extends EventEmitter_js_1.EventEmitter {\n  #client;\n  #world;\n  #id;\n  #name;\n  #disposables = new disposable_js_1.DisposableStack();\n  constructor(client, contextPayload, world) {\n    super();\n    this.#client = client;\n    this.#world = world;\n    this.#id = contextPayload.id;\n    if (contextPayload.name) {\n      this.#name = contextPayload.name;\n    }\n    const clientEmitter = this.#disposables.use(new EventEmitter_js_1.EventEmitter(this.#client));\n    clientEmitter.on('Runtime.bindingCalled', this.#onBindingCalled.bind(this));\n    clientEmitter.on('Runtime.executionContextDestroyed', async event => {\n      if (event.executionContextId === this.#id) {\n        this[disposable_js_1.disposeSymbol]();\n      }\n    });\n    clientEmitter.on('Runtime.executionContextsCleared', async () => {\n      this[disposable_js_1.disposeSymbol]();\n    });\n    clientEmitter.on('Runtime.consoleAPICalled', this.#onConsoleAPI.bind(this));\n    clientEmitter.on(CDPSession_js_1.CDPSessionEvent.Disconnected, () => {\n      this[disposable_js_1.disposeSymbol]();\n    });\n  }\n  // Contains mapping from functions that should be bound to Puppeteer functions.\n  #bindings = new Map();\n  // If multiple waitFor are set up asynchronously, we need to wait for the\n  // first one to set up the binding in the page before running the others.\n  #mutex = new Mutex_js_1.Mutex();\n  async #addBinding(binding) {\n    const env_1 = {\n      stack: [],\n      error: void 0,\n      hasError: false\n    };\n    try {\n      if (this.#bindings.has(binding.name)) {\n        return;\n      }\n      const _ = __addDisposableResource(env_1, await this.#mutex.acquire(), false);\n      try {\n        await this.#client.send('Runtime.addBinding', this.#name ? {\n          name: utils_js_1.CDP_BINDING_PREFIX + binding.name,\n          executionContextName: this.#name\n        } : {\n          name: utils_js_1.CDP_BINDING_PREFIX + binding.name,\n          executionContextId: this.#id\n        });\n        await this.evaluate(utils_js_1.addPageBinding, 'internal', binding.name, utils_js_1.CDP_BINDING_PREFIX);\n        this.#bindings.set(binding.name, binding);\n      } catch (error) {\n        // We could have tried to evaluate in a context which was already\n        // destroyed. This happens, for example, if the page is navigated while\n        // we are trying to add the binding\n        if (error instanceof Error) {\n          // Destroyed context.\n          if (error.message.includes('Execution context was destroyed')) {\n            return;\n          }\n          // Missing context.\n          if (error.message.includes('Cannot find context with specified id')) {\n            return;\n          }\n        }\n        (0, util_js_1.debugError)(error);\n      }\n    } catch (e_1) {\n      env_1.error = e_1;\n      env_1.hasError = true;\n    } finally {\n      __disposeResources(env_1);\n    }\n  }\n  async #onBindingCalled(event) {\n    if (event.executionContextId !== this.#id) {\n      return;\n    }\n    let payload;\n    try {\n      payload = JSON.parse(event.payload);\n    } catch {\n      // The binding was either called by something in the page or it was\n      // called before our wrapper was initialized.\n      return;\n    }\n    const {\n      type,\n      name,\n      seq,\n      args,\n      isTrivial\n    } = payload;\n    if (type !== 'internal') {\n      this.emit('bindingcalled', event);\n      return;\n    }\n    if (!this.#bindings.has(name)) {\n      this.emit('bindingcalled', event);\n      return;\n    }\n    try {\n      const binding = this.#bindings.get(name);\n      await binding?.run(this, seq, args, isTrivial);\n    } catch (err) {\n      (0, util_js_1.debugError)(err);\n    }\n  }\n  get id() {\n    return this.#id;\n  }\n  #onConsoleAPI(event) {\n    if (event.executionContextId !== this.#id) {\n      return;\n    }\n    this.emit('consoleapicalled', event);\n  }\n  #bindingsInstalled = false;\n  #puppeteerUtil;\n  get puppeteerUtil() {\n    let promise = Promise.resolve();\n    if (!this.#bindingsInstalled) {\n      promise = Promise.all([this.#addBindingWithoutThrowing(ariaQuerySelectorBinding), this.#addBindingWithoutThrowing(ariaQuerySelectorAllBinding)]);\n      this.#bindingsInstalled = true;\n    }\n    ScriptInjector_js_1.scriptInjector.inject(script => {\n      if (this.#puppeteerUtil) {\n        void this.#puppeteerUtil.then(handle => {\n          void handle.dispose();\n        });\n      }\n      this.#puppeteerUtil = promise.then(() => {\n        return this.evaluateHandle(script);\n      });\n    }, !this.#puppeteerUtil);\n    return this.#puppeteerUtil;\n  }\n  async #addBindingWithoutThrowing(binding) {\n    try {\n      await this.#addBinding(binding);\n    } catch (err) {\n      // If the binding cannot be added, then either the browser doesn't support\n      // bindings (e.g. Firefox) or the context is broken. Either breakage is\n      // okay, so we ignore the error.\n      (0, util_js_1.debugError)(err);\n    }\n  }\n  /**\n   * Evaluates the given function.\n   *\n   * @example\n   *\n   * ```ts\n   * const executionContext = await page.mainFrame().executionContext();\n   * const result = await executionContext.evaluate(() => Promise.resolve(8 * 7))* ;\n   * console.log(result); // prints \"56\"\n   * ```\n   *\n   * @example\n   * A string can also be passed in instead of a function:\n   *\n   * ```ts\n   * console.log(await executionContext.evaluate('1 + 2')); // prints \"3\"\n   * ```\n   *\n   * @example\n   * Handles can also be passed as `args`. They resolve to their referenced object:\n   *\n   * ```ts\n   * const oneHandle = await executionContext.evaluateHandle(() => 1);\n   * const twoHandle = await executionContext.evaluateHandle(() => 2);\n   * const result = await executionContext.evaluate(\n   *   (a, b) => a + b,\n   *   oneHandle,\n   *   twoHandle\n   * );\n   * await oneHandle.dispose();\n   * await twoHandle.dispose();\n   * console.log(result); // prints '3'.\n   * ```\n   *\n   * @param pageFunction - The function to evaluate.\n   * @param args - Additional arguments to pass into the function.\n   * @returns The result of evaluating the function. If the result is an object,\n   * a vanilla object containing the serializable properties of the result is\n   * returned.\n   */\n  async evaluate(pageFunction, ...args) {\n    return await this.#evaluate(true, pageFunction, ...args);\n  }\n  /**\n   * Evaluates the given function.\n   *\n   * Unlike {@link ExecutionContext.evaluate | evaluate}, this method returns a\n   * handle to the result of the function.\n   *\n   * This method may be better suited if the object cannot be serialized (e.g.\n   * `Map`) and requires further manipulation.\n   *\n   * @example\n   *\n   * ```ts\n   * const context = await page.mainFrame().executionContext();\n   * const handle: JSHandle<typeof globalThis> = await context.evaluateHandle(\n   *   () => Promise.resolve(self)\n   * );\n   * ```\n   *\n   * @example\n   * A string can also be passed in instead of a function.\n   *\n   * ```ts\n   * const handle: JSHandle<number> = await context.evaluateHandle('1 + 2');\n   * ```\n   *\n   * @example\n   * Handles can also be passed as `args`. They resolve to their referenced object:\n   *\n   * ```ts\n   * const bodyHandle: ElementHandle<HTMLBodyElement> =\n   *   await context.evaluateHandle(() => {\n   *     return document.body;\n   *   });\n   * const stringHandle: JSHandle<string> = await context.evaluateHandle(\n   *   body => body.innerHTML,\n   *   body\n   * );\n   * console.log(await stringHandle.jsonValue()); // prints body's innerHTML\n   * // Always dispose your garbage! :)\n   * await bodyHandle.dispose();\n   * await stringHandle.dispose();\n   * ```\n   *\n   * @param pageFunction - The function to evaluate.\n   * @param args - Additional arguments to pass into the function.\n   * @returns A {@link JSHandle | handle} to the result of evaluating the\n   * function. If the result is a `Node`, then this will return an\n   * {@link ElementHandle | element handle}.\n   */\n  async evaluateHandle(pageFunction, ...args) {\n    return await this.#evaluate(false, pageFunction, ...args);\n  }\n  async #evaluate(returnByValue, pageFunction, ...args) {\n    const sourceUrlComment = (0, util_js_1.getSourceUrlComment)((0, util_js_1.getSourcePuppeteerURLIfAvailable)(pageFunction)?.toString() ?? util_js_1.PuppeteerURL.INTERNAL_URL);\n    if ((0, util_js_1.isString)(pageFunction)) {\n      const contextId = this.#id;\n      const expression = pageFunction;\n      const expressionWithSourceUrl = util_js_1.SOURCE_URL_REGEX.test(expression) ? expression : `${expression}\\n${sourceUrlComment}\\n`;\n      const {\n        exceptionDetails,\n        result: remoteObject\n      } = await this.#client.send('Runtime.evaluate', {\n        expression: expressionWithSourceUrl,\n        contextId,\n        returnByValue,\n        awaitPromise: true,\n        userGesture: true\n      }).catch(rewriteError);\n      if (exceptionDetails) {\n        throw (0, utils_js_1.createEvaluationError)(exceptionDetails);\n      }\n      return returnByValue ? (0, utils_js_1.valueFromRemoteObject)(remoteObject) : this.#world.createCdpHandle(remoteObject);\n    }\n    const functionDeclaration = (0, Function_js_1.stringifyFunction)(pageFunction);\n    const functionDeclarationWithSourceUrl = util_js_1.SOURCE_URL_REGEX.test(functionDeclaration) ? functionDeclaration : `${functionDeclaration}\\n${sourceUrlComment}\\n`;\n    let callFunctionOnPromise;\n    try {\n      callFunctionOnPromise = this.#client.send('Runtime.callFunctionOn', {\n        functionDeclaration: functionDeclarationWithSourceUrl,\n        executionContextId: this.#id,\n        // LazyArgs are used only internally and should not affect the order\n        // evaluate calls for the public APIs.\n        arguments: args.some(arg => {\n          return arg instanceof LazyArg_js_1.LazyArg;\n        }) ? await Promise.all(args.map(arg => {\n          return convertArgumentAsync(this, arg);\n        })) : args.map(arg => {\n          return convertArgument(this, arg);\n        }),\n        returnByValue,\n        awaitPromise: true,\n        userGesture: true\n      });\n    } catch (error) {\n      if (error instanceof TypeError && error.message.startsWith('Converting circular structure to JSON')) {\n        error.message += ' Recursive objects are not allowed.';\n      }\n      throw error;\n    }\n    const {\n      exceptionDetails,\n      result: remoteObject\n    } = await callFunctionOnPromise.catch(rewriteError);\n    if (exceptionDetails) {\n      throw (0, utils_js_1.createEvaluationError)(exceptionDetails);\n    }\n    return returnByValue ? (0, utils_js_1.valueFromRemoteObject)(remoteObject) : this.#world.createCdpHandle(remoteObject);\n    async function convertArgumentAsync(context, arg) {\n      if (arg instanceof LazyArg_js_1.LazyArg) {\n        arg = await arg.get(context);\n      }\n      return convertArgument(context, arg);\n    }\n    function convertArgument(context, arg) {\n      if (typeof arg === 'bigint') {\n        // eslint-disable-line valid-typeof\n        return {\n          unserializableValue: `${arg.toString()}n`\n        };\n      }\n      if (Object.is(arg, -0)) {\n        return {\n          unserializableValue: '-0'\n        };\n      }\n      if (Object.is(arg, Infinity)) {\n        return {\n          unserializableValue: 'Infinity'\n        };\n      }\n      if (Object.is(arg, -Infinity)) {\n        return {\n          unserializableValue: '-Infinity'\n        };\n      }\n      if (Object.is(arg, NaN)) {\n        return {\n          unserializableValue: 'NaN'\n        };\n      }\n      const objectHandle = arg && (arg instanceof JSHandle_js_1.CdpJSHandle || arg instanceof ElementHandle_js_1.CdpElementHandle) ? arg : null;\n      if (objectHandle) {\n        if (objectHandle.realm !== context.#world) {\n          throw new Error('JSHandles can be evaluated only in the context they were created!');\n        }\n        if (objectHandle.disposed) {\n          throw new Error('JSHandle is disposed!');\n        }\n        if (objectHandle.remoteObject().unserializableValue) {\n          return {\n            unserializableValue: objectHandle.remoteObject().unserializableValue\n          };\n        }\n        if (!objectHandle.remoteObject().objectId) {\n          return {\n            value: objectHandle.remoteObject().value\n          };\n        }\n        return {\n          objectId: objectHandle.remoteObject().objectId\n        };\n      }\n      return {\n        value: arg\n      };\n    }\n  }\n  [disposable_js_1.disposeSymbol]() {\n    this.#disposables.dispose();\n    this.emit('disposed', undefined);\n  }\n}\nexports.ExecutionContext = ExecutionContext;\nconst rewriteError = error => {\n  if (error.message.includes('Object reference chain is too long')) {\n    return {\n      result: {\n        type: 'undefined'\n      }\n    };\n  }\n  if (error.message.includes(\"Object couldn't be returned by value\")) {\n    return {\n      result: {\n        type: 'undefined'\n      }\n    };\n  }\n  if (error.message.endsWith('Cannot find context with specified id') || error.message.endsWith('Inspected target navigated or closed')) {\n    throw new Error('Execution context was destroyed, most likely because of a navigation.');\n  }\n  throw error;\n};","map":{"version":3,"names":["CDPSession_js_1","require","EventEmitter_js_1","LazyArg_js_1","ScriptInjector_js_1","util_js_1","AsyncIterableUtil_js_1","disposable_js_1","Function_js_1","Mutex_js_1","AriaQueryHandler_js_1","Binding_js_1","ElementHandle_js_1","JSHandle_js_1","utils_js_1","ariaQuerySelectorBinding","Binding","ARIAQueryHandler","queryOne","ariaQuerySelectorAllBinding","element","selector","results","queryAll","realm","evaluateHandle","elements","AsyncIterableUtil","collect","ExecutionContext","EventEmitter","client","world","id","name","disposables","DisposableStack","constructor","contextPayload","clientEmitter","use","on","onBindingCalled","bind","event","executionContextId","disposeSymbol","onConsoleAPI","CDPSessionEvent","Disconnected","bindings","Map","mutex","Mutex","addBinding","#addBinding","binding","has","_","__addDisposableResource","env_1","acquire","send","CDP_BINDING_PREFIX","executionContextName","evaluate","addPageBinding","set","error","Error","message","includes","debugError","#onBindingCalled","payload","JSON","parse","type","seq","args","isTrivial","emit","get","run","err","#onConsoleAPI","bindingsInstalled","puppeteerUtil","promise","Promise","resolve","all","addBindingWithoutThrowing","scriptInjector","inject","script","then","handle","dispose","#addBindingWithoutThrowing","pageFunction","#evaluate","returnByValue","sourceUrlComment","getSourceUrlComment","getSourcePuppeteerURLIfAvailable","toString","PuppeteerURL","INTERNAL_URL","isString","contextId","expression","expressionWithSourceUrl","SOURCE_URL_REGEX","test","exceptionDetails","result","remoteObject","awaitPromise","userGesture","catch","rewriteError","createEvaluationError","valueFromRemoteObject","createCdpHandle","functionDeclaration","stringifyFunction","functionDeclarationWithSourceUrl","callFunctionOnPromise","arguments","some","arg","LazyArg","map","convertArgumentAsync","convertArgument","TypeError","startsWith","context","unserializableValue","Object","is","Infinity","NaN","objectHandle","CdpJSHandle","CdpElementHandle","disposed","objectId","value","undefined","exports","endsWith"],"sources":["/Users/lawj4/webDevelopment/node_modules/puppeteer-core/src/cdp/ExecutionContext.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2017 Google Inc.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport type {Protocol} from 'devtools-protocol';\n\nimport {CDPSessionEvent, type CDPSession} from '../api/CDPSession.js';\nimport type {ElementHandle} from '../api/ElementHandle.js';\nimport type {JSHandle} from '../api/JSHandle.js';\nimport {EventEmitter} from '../common/EventEmitter.js';\nimport {LazyArg} from '../common/LazyArg.js';\nimport {scriptInjector} from '../common/ScriptInjector.js';\nimport type {BindingPayload, EvaluateFunc, HandleFor} from '../common/types.js';\nimport {\n  PuppeteerURL,\n  SOURCE_URL_REGEX,\n  debugError,\n  getSourcePuppeteerURLIfAvailable,\n  getSourceUrlComment,\n  isString,\n} from '../common/util.js';\nimport type PuppeteerUtil from '../injected/injected.js';\nimport {AsyncIterableUtil} from '../util/AsyncIterableUtil.js';\nimport {DisposableStack, disposeSymbol} from '../util/disposable.js';\nimport {stringifyFunction} from '../util/Function.js';\nimport {Mutex} from '../util/Mutex.js';\n\nimport {ARIAQueryHandler} from './AriaQueryHandler.js';\nimport {Binding} from './Binding.js';\nimport {CdpElementHandle} from './ElementHandle.js';\nimport type {IsolatedWorld} from './IsolatedWorld.js';\nimport {CdpJSHandle} from './JSHandle.js';\nimport {\n  addPageBinding,\n  CDP_BINDING_PREFIX,\n  createEvaluationError,\n  valueFromRemoteObject,\n} from './utils.js';\n\nconst ariaQuerySelectorBinding = new Binding(\n  '__ariaQuerySelector',\n  ARIAQueryHandler.queryOne as (...args: unknown[]) => unknown,\n  '' // custom init\n);\n\nconst ariaQuerySelectorAllBinding = new Binding(\n  '__ariaQuerySelectorAll',\n  (async (\n    element: ElementHandle<Node>,\n    selector: string\n  ): Promise<JSHandle<Node[]>> => {\n    const results = ARIAQueryHandler.queryAll(element, selector);\n    return await element.realm.evaluateHandle(\n      (...elements) => {\n        return elements;\n      },\n      ...(await AsyncIterableUtil.collect(results))\n    );\n  }) as (...args: unknown[]) => unknown,\n  '' // custom init\n);\n\n/**\n * @internal\n */\nexport class ExecutionContext\n  extends EventEmitter<{\n    /** Emitted when this execution context is disposed. */\n    disposed: undefined;\n    consoleapicalled: Protocol.Runtime.ConsoleAPICalledEvent;\n    /** Emitted when a binding that is not installed by the ExecutionContext is called. */\n    bindingcalled: Protocol.Runtime.BindingCalledEvent;\n  }>\n  implements Disposable\n{\n  #client: CDPSession;\n  #world: IsolatedWorld;\n  #id: number;\n  #name?: string;\n\n  readonly #disposables = new DisposableStack();\n\n  constructor(\n    client: CDPSession,\n    contextPayload: Protocol.Runtime.ExecutionContextDescription,\n    world: IsolatedWorld\n  ) {\n    super();\n    this.#client = client;\n    this.#world = world;\n    this.#id = contextPayload.id;\n    if (contextPayload.name) {\n      this.#name = contextPayload.name;\n    }\n    const clientEmitter = this.#disposables.use(new EventEmitter(this.#client));\n    clientEmitter.on('Runtime.bindingCalled', this.#onBindingCalled.bind(this));\n    clientEmitter.on('Runtime.executionContextDestroyed', async event => {\n      if (event.executionContextId === this.#id) {\n        this[disposeSymbol]();\n      }\n    });\n    clientEmitter.on('Runtime.executionContextsCleared', async () => {\n      this[disposeSymbol]();\n    });\n    clientEmitter.on('Runtime.consoleAPICalled', this.#onConsoleAPI.bind(this));\n    clientEmitter.on(CDPSessionEvent.Disconnected, () => {\n      this[disposeSymbol]();\n    });\n  }\n\n  // Contains mapping from functions that should be bound to Puppeteer functions.\n  #bindings = new Map<string, Binding>();\n\n  // If multiple waitFor are set up asynchronously, we need to wait for the\n  // first one to set up the binding in the page before running the others.\n  #mutex = new Mutex();\n  async #addBinding(binding: Binding): Promise<void> {\n    if (this.#bindings.has(binding.name)) {\n      return;\n    }\n\n    using _ = await this.#mutex.acquire();\n    try {\n      await this.#client.send(\n        'Runtime.addBinding',\n        this.#name\n          ? {\n              name: CDP_BINDING_PREFIX + binding.name,\n              executionContextName: this.#name,\n            }\n          : {\n              name: CDP_BINDING_PREFIX + binding.name,\n              executionContextId: this.#id,\n            }\n      );\n\n      await this.evaluate(\n        addPageBinding,\n        'internal',\n        binding.name,\n        CDP_BINDING_PREFIX\n      );\n\n      this.#bindings.set(binding.name, binding);\n    } catch (error) {\n      // We could have tried to evaluate in a context which was already\n      // destroyed. This happens, for example, if the page is navigated while\n      // we are trying to add the binding\n      if (error instanceof Error) {\n        // Destroyed context.\n        if (error.message.includes('Execution context was destroyed')) {\n          return;\n        }\n        // Missing context.\n        if (error.message.includes('Cannot find context with specified id')) {\n          return;\n        }\n      }\n\n      debugError(error);\n    }\n  }\n\n  async #onBindingCalled(\n    event: Protocol.Runtime.BindingCalledEvent\n  ): Promise<void> {\n    if (event.executionContextId !== this.#id) {\n      return;\n    }\n\n    let payload: BindingPayload;\n    try {\n      payload = JSON.parse(event.payload);\n    } catch {\n      // The binding was either called by something in the page or it was\n      // called before our wrapper was initialized.\n      return;\n    }\n    const {type, name, seq, args, isTrivial} = payload;\n    if (type !== 'internal') {\n      this.emit('bindingcalled', event);\n      return;\n    }\n    if (!this.#bindings.has(name)) {\n      this.emit('bindingcalled', event);\n      return;\n    }\n\n    try {\n      const binding = this.#bindings.get(name);\n      await binding?.run(this, seq, args, isTrivial);\n    } catch (err) {\n      debugError(err);\n    }\n  }\n\n  get id(): number {\n    return this.#id;\n  }\n\n  #onConsoleAPI(event: Protocol.Runtime.ConsoleAPICalledEvent): void {\n    if (event.executionContextId !== this.#id) {\n      return;\n    }\n    this.emit('consoleapicalled', event);\n  }\n\n  #bindingsInstalled = false;\n  #puppeteerUtil?: Promise<JSHandle<PuppeteerUtil>>;\n  get puppeteerUtil(): Promise<JSHandle<PuppeteerUtil>> {\n    let promise = Promise.resolve() as Promise<unknown>;\n    if (!this.#bindingsInstalled) {\n      promise = Promise.all([\n        this.#addBindingWithoutThrowing(ariaQuerySelectorBinding),\n        this.#addBindingWithoutThrowing(ariaQuerySelectorAllBinding),\n      ]);\n      this.#bindingsInstalled = true;\n    }\n    scriptInjector.inject(script => {\n      if (this.#puppeteerUtil) {\n        void this.#puppeteerUtil.then(handle => {\n          void handle.dispose();\n        });\n      }\n      this.#puppeteerUtil = promise.then(() => {\n        return this.evaluateHandle(script) as Promise<JSHandle<PuppeteerUtil>>;\n      });\n    }, !this.#puppeteerUtil);\n    return this.#puppeteerUtil as Promise<JSHandle<PuppeteerUtil>>;\n  }\n\n  async #addBindingWithoutThrowing(binding: Binding) {\n    try {\n      await this.#addBinding(binding);\n    } catch (err) {\n      // If the binding cannot be added, then either the browser doesn't support\n      // bindings (e.g. Firefox) or the context is broken. Either breakage is\n      // okay, so we ignore the error.\n      debugError(err);\n    }\n  }\n\n  /**\n   * Evaluates the given function.\n   *\n   * @example\n   *\n   * ```ts\n   * const executionContext = await page.mainFrame().executionContext();\n   * const result = await executionContext.evaluate(() => Promise.resolve(8 * 7))* ;\n   * console.log(result); // prints \"56\"\n   * ```\n   *\n   * @example\n   * A string can also be passed in instead of a function:\n   *\n   * ```ts\n   * console.log(await executionContext.evaluate('1 + 2')); // prints \"3\"\n   * ```\n   *\n   * @example\n   * Handles can also be passed as `args`. They resolve to their referenced object:\n   *\n   * ```ts\n   * const oneHandle = await executionContext.evaluateHandle(() => 1);\n   * const twoHandle = await executionContext.evaluateHandle(() => 2);\n   * const result = await executionContext.evaluate(\n   *   (a, b) => a + b,\n   *   oneHandle,\n   *   twoHandle\n   * );\n   * await oneHandle.dispose();\n   * await twoHandle.dispose();\n   * console.log(result); // prints '3'.\n   * ```\n   *\n   * @param pageFunction - The function to evaluate.\n   * @param args - Additional arguments to pass into the function.\n   * @returns The result of evaluating the function. If the result is an object,\n   * a vanilla object containing the serializable properties of the result is\n   * returned.\n   */\n  async evaluate<\n    Params extends unknown[],\n    Func extends EvaluateFunc<Params> = EvaluateFunc<Params>,\n  >(\n    pageFunction: Func | string,\n    ...args: Params\n  ): Promise<Awaited<ReturnType<Func>>> {\n    return await this.#evaluate(true, pageFunction, ...args);\n  }\n\n  /**\n   * Evaluates the given function.\n   *\n   * Unlike {@link ExecutionContext.evaluate | evaluate}, this method returns a\n   * handle to the result of the function.\n   *\n   * This method may be better suited if the object cannot be serialized (e.g.\n   * `Map`) and requires further manipulation.\n   *\n   * @example\n   *\n   * ```ts\n   * const context = await page.mainFrame().executionContext();\n   * const handle: JSHandle<typeof globalThis> = await context.evaluateHandle(\n   *   () => Promise.resolve(self)\n   * );\n   * ```\n   *\n   * @example\n   * A string can also be passed in instead of a function.\n   *\n   * ```ts\n   * const handle: JSHandle<number> = await context.evaluateHandle('1 + 2');\n   * ```\n   *\n   * @example\n   * Handles can also be passed as `args`. They resolve to their referenced object:\n   *\n   * ```ts\n   * const bodyHandle: ElementHandle<HTMLBodyElement> =\n   *   await context.evaluateHandle(() => {\n   *     return document.body;\n   *   });\n   * const stringHandle: JSHandle<string> = await context.evaluateHandle(\n   *   body => body.innerHTML,\n   *   body\n   * );\n   * console.log(await stringHandle.jsonValue()); // prints body's innerHTML\n   * // Always dispose your garbage! :)\n   * await bodyHandle.dispose();\n   * await stringHandle.dispose();\n   * ```\n   *\n   * @param pageFunction - The function to evaluate.\n   * @param args - Additional arguments to pass into the function.\n   * @returns A {@link JSHandle | handle} to the result of evaluating the\n   * function. If the result is a `Node`, then this will return an\n   * {@link ElementHandle | element handle}.\n   */\n  async evaluateHandle<\n    Params extends unknown[],\n    Func extends EvaluateFunc<Params> = EvaluateFunc<Params>,\n  >(\n    pageFunction: Func | string,\n    ...args: Params\n  ): Promise<HandleFor<Awaited<ReturnType<Func>>>> {\n    return await this.#evaluate(false, pageFunction, ...args);\n  }\n\n  async #evaluate<\n    Params extends unknown[],\n    Func extends EvaluateFunc<Params> = EvaluateFunc<Params>,\n  >(\n    returnByValue: true,\n    pageFunction: Func | string,\n    ...args: Params\n  ): Promise<Awaited<ReturnType<Func>>>;\n  async #evaluate<\n    Params extends unknown[],\n    Func extends EvaluateFunc<Params> = EvaluateFunc<Params>,\n  >(\n    returnByValue: false,\n    pageFunction: Func | string,\n    ...args: Params\n  ): Promise<HandleFor<Awaited<ReturnType<Func>>>>;\n  async #evaluate<\n    Params extends unknown[],\n    Func extends EvaluateFunc<Params> = EvaluateFunc<Params>,\n  >(\n    returnByValue: boolean,\n    pageFunction: Func | string,\n    ...args: Params\n  ): Promise<HandleFor<Awaited<ReturnType<Func>>> | Awaited<ReturnType<Func>>> {\n    const sourceUrlComment = getSourceUrlComment(\n      getSourcePuppeteerURLIfAvailable(pageFunction)?.toString() ??\n        PuppeteerURL.INTERNAL_URL\n    );\n\n    if (isString(pageFunction)) {\n      const contextId = this.#id;\n      const expression = pageFunction;\n      const expressionWithSourceUrl = SOURCE_URL_REGEX.test(expression)\n        ? expression\n        : `${expression}\\n${sourceUrlComment}\\n`;\n\n      const {exceptionDetails, result: remoteObject} = await this.#client\n        .send('Runtime.evaluate', {\n          expression: expressionWithSourceUrl,\n          contextId,\n          returnByValue,\n          awaitPromise: true,\n          userGesture: true,\n        })\n        .catch(rewriteError);\n\n      if (exceptionDetails) {\n        throw createEvaluationError(exceptionDetails);\n      }\n\n      return returnByValue\n        ? valueFromRemoteObject(remoteObject)\n        : this.#world.createCdpHandle(remoteObject);\n    }\n\n    const functionDeclaration = stringifyFunction(pageFunction);\n    const functionDeclarationWithSourceUrl = SOURCE_URL_REGEX.test(\n      functionDeclaration\n    )\n      ? functionDeclaration\n      : `${functionDeclaration}\\n${sourceUrlComment}\\n`;\n    let callFunctionOnPromise;\n    try {\n      callFunctionOnPromise = this.#client.send('Runtime.callFunctionOn', {\n        functionDeclaration: functionDeclarationWithSourceUrl,\n        executionContextId: this.#id,\n        // LazyArgs are used only internally and should not affect the order\n        // evaluate calls for the public APIs.\n        arguments: args.some(arg => {\n          return arg instanceof LazyArg;\n        })\n          ? await Promise.all(\n              args.map(arg => {\n                return convertArgumentAsync(this, arg);\n              })\n            )\n          : args.map(arg => {\n              return convertArgument(this, arg);\n            }),\n        returnByValue,\n        awaitPromise: true,\n        userGesture: true,\n      });\n    } catch (error) {\n      if (\n        error instanceof TypeError &&\n        error.message.startsWith('Converting circular structure to JSON')\n      ) {\n        error.message += ' Recursive objects are not allowed.';\n      }\n      throw error;\n    }\n    const {exceptionDetails, result: remoteObject} =\n      await callFunctionOnPromise.catch(rewriteError);\n    if (exceptionDetails) {\n      throw createEvaluationError(exceptionDetails);\n    }\n    return returnByValue\n      ? valueFromRemoteObject(remoteObject)\n      : this.#world.createCdpHandle(remoteObject);\n\n    async function convertArgumentAsync(\n      context: ExecutionContext,\n      arg: unknown\n    ) {\n      if (arg instanceof LazyArg) {\n        arg = await arg.get(context);\n      }\n      return convertArgument(context, arg);\n    }\n\n    function convertArgument(\n      context: ExecutionContext,\n      arg: unknown\n    ): Protocol.Runtime.CallArgument {\n      if (typeof arg === 'bigint') {\n        // eslint-disable-line valid-typeof\n        return {unserializableValue: `${arg.toString()}n`};\n      }\n      if (Object.is(arg, -0)) {\n        return {unserializableValue: '-0'};\n      }\n      if (Object.is(arg, Infinity)) {\n        return {unserializableValue: 'Infinity'};\n      }\n      if (Object.is(arg, -Infinity)) {\n        return {unserializableValue: '-Infinity'};\n      }\n      if (Object.is(arg, NaN)) {\n        return {unserializableValue: 'NaN'};\n      }\n      const objectHandle =\n        arg && (arg instanceof CdpJSHandle || arg instanceof CdpElementHandle)\n          ? arg\n          : null;\n      if (objectHandle) {\n        if (objectHandle.realm !== context.#world) {\n          throw new Error(\n            'JSHandles can be evaluated only in the context they were created!'\n          );\n        }\n        if (objectHandle.disposed) {\n          throw new Error('JSHandle is disposed!');\n        }\n        if (objectHandle.remoteObject().unserializableValue) {\n          return {\n            unserializableValue:\n              objectHandle.remoteObject().unserializableValue,\n          };\n        }\n        if (!objectHandle.remoteObject().objectId) {\n          return {value: objectHandle.remoteObject().value};\n        }\n        return {objectId: objectHandle.remoteObject().objectId};\n      }\n      return {value: arg};\n    }\n  }\n\n  [disposeSymbol](): void {\n    this.#disposables.dispose();\n    this.emit('disposed', undefined);\n  }\n}\n\nconst rewriteError = (error: Error): Protocol.Runtime.EvaluateResponse => {\n  if (error.message.includes('Object reference chain is too long')) {\n    return {result: {type: 'undefined'}};\n  }\n  if (error.message.includes(\"Object couldn't be returned by value\")) {\n    return {result: {type: 'undefined'}};\n  }\n\n  if (\n    error.message.endsWith('Cannot find context with specified id') ||\n    error.message.endsWith('Inspected target navigated or closed')\n  ) {\n    throw new Error(\n      'Execution context was destroyed, most likely because of a navigation.'\n    );\n  }\n  throw error;\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}