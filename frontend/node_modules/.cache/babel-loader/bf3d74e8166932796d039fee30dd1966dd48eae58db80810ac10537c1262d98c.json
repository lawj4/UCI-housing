{"ast":null,"code":"\"use strict\";\n\n/**\n * @license\n * Copyright 2018 Google Inc.\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.WebWorker = void 0;\nconst Errors_js_1 = require(\"../common/Errors.js\");\nconst EventEmitter_js_1 = require(\"../common/EventEmitter.js\");\nconst TimeoutSettings_js_1 = require(\"../common/TimeoutSettings.js\");\nconst util_js_1 = require(\"../common/util.js\");\n/**\n * This class represents a\n * {@link https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API | WebWorker}.\n *\n * @remarks\n * The events `workercreated` and `workerdestroyed` are emitted on the page\n * object to signal the worker lifecycle.\n *\n * @example\n *\n * ```ts\n * page.on('workercreated', worker =>\n *   console.log('Worker created: ' + worker.url())\n * );\n * page.on('workerdestroyed', worker =>\n *   console.log('Worker destroyed: ' + worker.url())\n * );\n *\n * console.log('Current workers:');\n * for (const worker of page.workers()) {\n *   console.log('  ' + worker.url());\n * }\n * ```\n *\n * @public\n */\nclass WebWorker extends EventEmitter_js_1.EventEmitter {\n  /**\n   * @internal\n   */\n  timeoutSettings = new TimeoutSettings_js_1.TimeoutSettings();\n  #url;\n  /**\n   * @internal\n   */\n  constructor(url) {\n    super();\n    this.#url = url;\n  }\n  /**\n   * The URL of this web worker.\n   */\n  url() {\n    return this.#url;\n  }\n  /**\n   * Evaluates a given function in the {@link WebWorker | worker}.\n   *\n   * @remarks If the given function returns a promise,\n   * {@link WebWorker.evaluate | evaluate} will wait for the promise to resolve.\n   *\n   * As a rule of thumb, if the return value of the given function is more\n   * complicated than a JSON object (e.g. most classes), then\n   * {@link WebWorker.evaluate | evaluate} will _likely_ return some truncated\n   * value (or `{}`). This is because we are not returning the actual return\n   * value, but a deserialized version as a result of transferring the return\n   * value through a protocol to Puppeteer.\n   *\n   * In general, you should use\n   * {@link WebWorker.evaluateHandle | evaluateHandle} if\n   * {@link WebWorker.evaluate | evaluate} cannot serialize the return value\n   * properly or you need a mutable {@link JSHandle | handle} to the return\n   * object.\n   *\n   * @param func - Function to be evaluated.\n   * @param args - Arguments to pass into `func`.\n   * @returns The result of `func`.\n   */\n  async evaluate(func, ...args) {\n    func = (0, util_js_1.withSourcePuppeteerURLIfNone)(this.evaluate.name, func);\n    return await this.mainRealm().evaluate(func, ...args);\n  }\n  /**\n   * Evaluates a given function in the {@link WebWorker | worker}.\n   *\n   * @remarks If the given function returns a promise,\n   * {@link WebWorker.evaluate | evaluate} will wait for the promise to resolve.\n   *\n   * In general, you should use\n   * {@link WebWorker.evaluateHandle | evaluateHandle} if\n   * {@link WebWorker.evaluate | evaluate} cannot serialize the return value\n   * properly or you need a mutable {@link JSHandle | handle} to the return\n   * object.\n   *\n   * @param func - Function to be evaluated.\n   * @param args - Arguments to pass into `func`.\n   * @returns A {@link JSHandle | handle} to the return value of `func`.\n   */\n  async evaluateHandle(func, ...args) {\n    func = (0, util_js_1.withSourcePuppeteerURLIfNone)(this.evaluateHandle.name, func);\n    return await this.mainRealm().evaluateHandle(func, ...args);\n  }\n  async close() {\n    throw new Errors_js_1.UnsupportedOperation('WebWorker.close() is not supported');\n  }\n}\nexports.WebWorker = WebWorker;","map":{"version":3,"names":["Errors_js_1","require","EventEmitter_js_1","TimeoutSettings_js_1","util_js_1","WebWorker","EventEmitter","timeoutSettings","TimeoutSettings","url","constructor","evaluate","func","args","withSourcePuppeteerURLIfNone","name","mainRealm","evaluateHandle","close","UnsupportedOperation","exports"],"sources":["/Users/lawj4/webDevelopment/Todo-List/frontend/node_modules/puppeteer-core/src/api/WebWorker.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2018 Google Inc.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport {UnsupportedOperation} from '../common/Errors.js';\nimport {EventEmitter, type EventType} from '../common/EventEmitter.js';\nimport {TimeoutSettings} from '../common/TimeoutSettings.js';\nimport type {EvaluateFunc, HandleFor} from '../common/types.js';\nimport {withSourcePuppeteerURLIfNone} from '../common/util.js';\n\nimport type {CDPSession} from './CDPSession.js';\nimport type {Realm} from './Realm.js';\n\n/**\n * This class represents a\n * {@link https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API | WebWorker}.\n *\n * @remarks\n * The events `workercreated` and `workerdestroyed` are emitted on the page\n * object to signal the worker lifecycle.\n *\n * @example\n *\n * ```ts\n * page.on('workercreated', worker =>\n *   console.log('Worker created: ' + worker.url())\n * );\n * page.on('workerdestroyed', worker =>\n *   console.log('Worker destroyed: ' + worker.url())\n * );\n *\n * console.log('Current workers:');\n * for (const worker of page.workers()) {\n *   console.log('  ' + worker.url());\n * }\n * ```\n *\n * @public\n */\nexport abstract class WebWorker extends EventEmitter<\n  Record<EventType, unknown>\n> {\n  /**\n   * @internal\n   */\n  readonly timeoutSettings = new TimeoutSettings();\n\n  readonly #url: string;\n\n  /**\n   * @internal\n   */\n  constructor(url: string) {\n    super();\n\n    this.#url = url;\n  }\n\n  /**\n   * @internal\n   */\n  abstract mainRealm(): Realm;\n\n  /**\n   * The URL of this web worker.\n   */\n  url(): string {\n    return this.#url;\n  }\n\n  /**\n   * The CDP session client the WebWorker belongs to.\n   */\n  abstract get client(): CDPSession;\n\n  /**\n   * Evaluates a given function in the {@link WebWorker | worker}.\n   *\n   * @remarks If the given function returns a promise,\n   * {@link WebWorker.evaluate | evaluate} will wait for the promise to resolve.\n   *\n   * As a rule of thumb, if the return value of the given function is more\n   * complicated than a JSON object (e.g. most classes), then\n   * {@link WebWorker.evaluate | evaluate} will _likely_ return some truncated\n   * value (or `{}`). This is because we are not returning the actual return\n   * value, but a deserialized version as a result of transferring the return\n   * value through a protocol to Puppeteer.\n   *\n   * In general, you should use\n   * {@link WebWorker.evaluateHandle | evaluateHandle} if\n   * {@link WebWorker.evaluate | evaluate} cannot serialize the return value\n   * properly or you need a mutable {@link JSHandle | handle} to the return\n   * object.\n   *\n   * @param func - Function to be evaluated.\n   * @param args - Arguments to pass into `func`.\n   * @returns The result of `func`.\n   */\n  async evaluate<\n    Params extends unknown[],\n    Func extends EvaluateFunc<Params> = EvaluateFunc<Params>,\n  >(func: Func | string, ...args: Params): Promise<Awaited<ReturnType<Func>>> {\n    func = withSourcePuppeteerURLIfNone(this.evaluate.name, func);\n    return await this.mainRealm().evaluate(func, ...args);\n  }\n\n  /**\n   * Evaluates a given function in the {@link WebWorker | worker}.\n   *\n   * @remarks If the given function returns a promise,\n   * {@link WebWorker.evaluate | evaluate} will wait for the promise to resolve.\n   *\n   * In general, you should use\n   * {@link WebWorker.evaluateHandle | evaluateHandle} if\n   * {@link WebWorker.evaluate | evaluate} cannot serialize the return value\n   * properly or you need a mutable {@link JSHandle | handle} to the return\n   * object.\n   *\n   * @param func - Function to be evaluated.\n   * @param args - Arguments to pass into `func`.\n   * @returns A {@link JSHandle | handle} to the return value of `func`.\n   */\n  async evaluateHandle<\n    Params extends unknown[],\n    Func extends EvaluateFunc<Params> = EvaluateFunc<Params>,\n  >(\n    func: Func | string,\n    ...args: Params\n  ): Promise<HandleFor<Awaited<ReturnType<Func>>>> {\n    func = withSourcePuppeteerURLIfNone(this.evaluateHandle.name, func);\n    return await this.mainRealm().evaluateHandle(func, ...args);\n  }\n\n  async close(): Promise<void> {\n    throw new UnsupportedOperation('WebWorker.close() is not supported');\n  }\n}\n"],"mappings":";;AAAA;;;;;;;;;AAMA,MAAAA,WAAA,GAAAC,OAAA;AACA,MAAAC,iBAAA,GAAAD,OAAA;AACA,MAAAE,oBAAA,GAAAF,OAAA;AAEA,MAAAG,SAAA,GAAAH,OAAA;AAKA;;;;;;;;;;;;;;;;;;;;;;;;;;AA0BA,MAAsBI,SAAU,SAAQH,iBAAA,CAAAI,YAEvC;EACC;;;EAGSC,eAAe,GAAG,IAAIJ,oBAAA,CAAAK,eAAe,EAAE;EAEvC,CAAAC,GAAI;EAEb;;;EAGAC,YAAYD,GAAW;IACrB,KAAK,EAAE;IAEP,IAAI,CAAC,CAAAA,GAAI,GAAGA,GAAG;EACjB;EAOA;;;EAGAA,GAAGA,CAAA;IACD,OAAO,IAAI,CAAC,CAAAA,GAAI;EAClB;EAOA;;;;;;;;;;;;;;;;;;;;;;;EAuBA,MAAME,QAAQA,CAGZC,IAAmB,EAAE,GAAGC,IAAY;IACpCD,IAAI,GAAG,IAAAR,SAAA,CAAAU,4BAA4B,EAAC,IAAI,CAACH,QAAQ,CAACI,IAAI,EAAEH,IAAI,CAAC;IAC7D,OAAO,MAAM,IAAI,CAACI,SAAS,EAAE,CAACL,QAAQ,CAACC,IAAI,EAAE,GAAGC,IAAI,CAAC;EACvD;EAEA;;;;;;;;;;;;;;;;EAgBA,MAAMI,cAAcA,CAIlBL,IAAmB,EACnB,GAAGC,IAAY;IAEfD,IAAI,GAAG,IAAAR,SAAA,CAAAU,4BAA4B,EAAC,IAAI,CAACG,cAAc,CAACF,IAAI,EAAEH,IAAI,CAAC;IACnE,OAAO,MAAM,IAAI,CAACI,SAAS,EAAE,CAACC,cAAc,CAACL,IAAI,EAAE,GAAGC,IAAI,CAAC;EAC7D;EAEA,MAAMK,KAAKA,CAAA;IACT,MAAM,IAAIlB,WAAA,CAAAmB,oBAAoB,CAAC,oCAAoC,CAAC;EACtE;;AAhGFC,OAAA,CAAAf,SAAA,GAAAA,SAAA","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}