{"ast":null,"code":"\"use strict\";\n\n/**\n * @license\n * Copyright 2023 Google Inc.\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Realm = void 0;\nconst WaitTask_js_1 = require(\"../common/WaitTask.js\");\nconst disposable_js_1 = require(\"../util/disposable.js\");\n/**\n * @internal\n */\nclass Realm {\n  timeoutSettings;\n  taskManager = new WaitTask_js_1.TaskManager();\n  constructor(timeoutSettings) {\n    this.timeoutSettings = timeoutSettings;\n  }\n  async waitForFunction(pageFunction, options = {}, ...args) {\n    const {\n      polling = 'raf',\n      timeout = this.timeoutSettings.timeout(),\n      root,\n      signal\n    } = options;\n    if (typeof polling === 'number' && polling < 0) {\n      throw new Error('Cannot poll with non-positive interval');\n    }\n    const waitTask = new WaitTask_js_1.WaitTask(this, {\n      polling,\n      root,\n      timeout,\n      signal\n    }, pageFunction, ...args);\n    return await waitTask.result;\n  }\n  get disposed() {\n    return this.#disposed;\n  }\n  #disposed = false;\n  /** @internal */\n  dispose() {\n    this.#disposed = true;\n    this.taskManager.terminateAll(new Error('waitForFunction failed: frame got detached.'));\n  }\n  /** @internal */\n  [disposable_js_1.disposeSymbol]() {\n    this.dispose();\n  }\n}\nexports.Realm = Realm;","map":{"version":3,"names":["WaitTask_js_1","require","disposable_js_1","Realm","timeoutSettings","taskManager","TaskManager","constructor","waitForFunction","pageFunction","options","args","polling","timeout","root","signal","Error","waitTask","WaitTask","result","disposed","dispose","terminateAll","disposeSymbol","exports"],"sources":["/Users/lawj4/webDevelopment/Todo-List/frontend/node_modules/puppeteer-core/src/api/Realm.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2023 Google Inc.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport type {TimeoutSettings} from '../common/TimeoutSettings.js';\nimport type {\n  EvaluateFunc,\n  HandleFor,\n  InnerLazyParams,\n} from '../common/types.js';\nimport {TaskManager, WaitTask} from '../common/WaitTask.js';\nimport {disposeSymbol} from '../util/disposable.js';\n\nimport type {ElementHandle} from './ElementHandle.js';\nimport type {Environment} from './Environment.js';\nimport type {JSHandle} from './JSHandle.js';\n\n/**\n * @internal\n */\nexport abstract class Realm implements Disposable {\n  protected readonly timeoutSettings: TimeoutSettings;\n  readonly taskManager = new TaskManager();\n\n  constructor(timeoutSettings: TimeoutSettings) {\n    this.timeoutSettings = timeoutSettings;\n  }\n\n  abstract get environment(): Environment;\n\n  abstract adoptHandle<T extends JSHandle<Node>>(handle: T): Promise<T>;\n  abstract transferHandle<T extends JSHandle<Node>>(handle: T): Promise<T>;\n  abstract evaluateHandle<\n    Params extends unknown[],\n    Func extends EvaluateFunc<Params> = EvaluateFunc<Params>,\n  >(\n    pageFunction: Func | string,\n    ...args: Params\n  ): Promise<HandleFor<Awaited<ReturnType<Func>>>>;\n  abstract evaluate<\n    Params extends unknown[],\n    Func extends EvaluateFunc<Params> = EvaluateFunc<Params>,\n  >(\n    pageFunction: Func | string,\n    ...args: Params\n  ): Promise<Awaited<ReturnType<Func>>>;\n\n  async waitForFunction<\n    Params extends unknown[],\n    Func extends EvaluateFunc<InnerLazyParams<Params>> = EvaluateFunc<\n      InnerLazyParams<Params>\n    >,\n  >(\n    pageFunction: Func | string,\n    options: {\n      polling?: 'raf' | 'mutation' | number;\n      timeout?: number;\n      root?: ElementHandle<Node>;\n      signal?: AbortSignal;\n    } = {},\n    ...args: Params\n  ): Promise<HandleFor<Awaited<ReturnType<Func>>>> {\n    const {\n      polling = 'raf',\n      timeout = this.timeoutSettings.timeout(),\n      root,\n      signal,\n    } = options;\n    if (typeof polling === 'number' && polling < 0) {\n      throw new Error('Cannot poll with non-positive interval');\n    }\n    const waitTask = new WaitTask(\n      this,\n      {\n        polling,\n        root,\n        timeout,\n        signal,\n      },\n      pageFunction as unknown as\n        | ((...args: unknown[]) => Promise<Awaited<ReturnType<Func>>>)\n        | string,\n      ...args\n    );\n    return await waitTask.result;\n  }\n\n  abstract adoptBackendNode(backendNodeId?: number): Promise<JSHandle<Node>>;\n\n  get disposed(): boolean {\n    return this.#disposed;\n  }\n\n  #disposed = false;\n  /** @internal */\n  dispose(): void {\n    this.#disposed = true;\n    this.taskManager.terminateAll(\n      new Error('waitForFunction failed: frame got detached.')\n    );\n  }\n  /** @internal */\n  [disposeSymbol](): void {\n    this.dispose();\n  }\n}\n"],"mappings":";;AAAA;;;;;;;;;AAYA,MAAAA,aAAA,GAAAC,OAAA;AACA,MAAAC,eAAA,GAAAD,OAAA;AAMA;;;AAGA,MAAsBE,KAAK;EACNC,eAAe;EACzBC,WAAW,GAAG,IAAIL,aAAA,CAAAM,WAAW,EAAE;EAExCC,YAAYH,eAAgC;IAC1C,IAAI,CAACA,eAAe,GAAGA,eAAe;EACxC;EAqBA,MAAMI,eAAeA,CAMnBC,YAA2B,EAC3BC,OAAA,GAKI,EAAE,EACN,GAAGC,IAAY;IAEf,MAAM;MACJC,OAAO,GAAG,KAAK;MACfC,OAAO,GAAG,IAAI,CAACT,eAAe,CAACS,OAAO,EAAE;MACxCC,IAAI;MACJC;IAAM,CACP,GAAGL,OAAO;IACX,IAAI,OAAOE,OAAO,KAAK,QAAQ,IAAIA,OAAO,GAAG,CAAC,EAAE;MAC9C,MAAM,IAAII,KAAK,CAAC,wCAAwC,CAAC;IAC3D;IACA,MAAMC,QAAQ,GAAG,IAAIjB,aAAA,CAAAkB,QAAQ,CAC3B,IAAI,EACJ;MACEN,OAAO;MACPE,IAAI;MACJD,OAAO;MACPE;KACD,EACDN,YAEU,EACV,GAAGE,IAAI,CACR;IACD,OAAO,MAAMM,QAAQ,CAACE,MAAM;EAC9B;EAIA,IAAIC,QAAQA,CAAA;IACV,OAAO,IAAI,CAAC,CAAAA,QAAS;EACvB;EAEA,CAAAA,QAAS,GAAG,KAAK;EACjB;EACAC,OAAOA,CAAA;IACL,IAAI,CAAC,CAAAD,QAAS,GAAG,IAAI;IACrB,IAAI,CAACf,WAAW,CAACiB,YAAY,CAC3B,IAAIN,KAAK,CAAC,6CAA6C,CAAC,CACzD;EACH;EACA;EACA,CAACd,eAAA,CAAAqB,aAAa,IAAC;IACb,IAAI,CAACF,OAAO,EAAE;EAChB;;AApFFG,OAAA,CAAArB,KAAA,GAAAA,KAAA","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}