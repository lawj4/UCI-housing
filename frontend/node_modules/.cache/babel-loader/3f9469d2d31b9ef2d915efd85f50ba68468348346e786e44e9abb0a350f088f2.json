{"ast":null,"code":"\"use strict\";\n\n/**\n * @license\n * Copyright 2024 Google Inc.\n * SPDX-License-Identifier: Apache-2.0\n */\nvar __runInitializers = this && this.__runInitializers || function (thisArg, initializers, value) {\n  var useValue = arguments.length > 2;\n  for (var i = 0; i < initializers.length; i++) {\n    value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);\n  }\n  return useValue ? value : void 0;\n};\nvar __esDecorate = this && this.__esDecorate || function (ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {\n  function accept(f) {\n    if (f !== void 0 && typeof f !== \"function\") throw new TypeError(\"Function expected\");\n    return f;\n  }\n  var kind = contextIn.kind,\n    key = kind === \"getter\" ? \"get\" : kind === \"setter\" ? \"set\" : \"value\";\n  var target = !descriptorIn && ctor ? contextIn[\"static\"] ? ctor : ctor.prototype : null;\n  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});\n  var _,\n    done = false;\n  for (var i = decorators.length - 1; i >= 0; i--) {\n    var context = {};\n    for (var p in contextIn) context[p] = p === \"access\" ? {} : contextIn[p];\n    for (var p in contextIn.access) context.access[p] = contextIn.access[p];\n    context.addInitializer = function (f) {\n      if (done) throw new TypeError(\"Cannot add initializers after decoration has completed\");\n      extraInitializers.push(accept(f || null));\n    };\n    var result = (0, decorators[i])(kind === \"accessor\" ? {\n      get: descriptor.get,\n      set: descriptor.set\n    } : descriptor[key], context);\n    if (kind === \"accessor\") {\n      if (result === void 0) continue;\n      if (result === null || typeof result !== \"object\") throw new TypeError(\"Object expected\");\n      if (_ = accept(result.get)) descriptor.get = _;\n      if (_ = accept(result.set)) descriptor.set = _;\n      if (_ = accept(result.init)) initializers.unshift(_);\n    } else if (_ = accept(result)) {\n      if (kind === \"field\") initializers.unshift(_);else descriptor[key] = _;\n    }\n  }\n  if (target) Object.defineProperty(target, contextIn.name, descriptor);\n  done = true;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Session = void 0;\nconst EventEmitter_js_1 = require(\"../../common/EventEmitter.js\");\nconst decorators_js_1 = require(\"../../util/decorators.js\");\nconst disposable_js_1 = require(\"../../util/disposable.js\");\nconst Browser_js_1 = require(\"./Browser.js\");\n/**\n * @internal\n */\nlet Session = (() => {\n  let _classSuper = EventEmitter_js_1.EventEmitter;\n  let _instanceExtraInitializers = [];\n  let _connection_decorators;\n  let _connection_initializers = [];\n  let _connection_extraInitializers = [];\n  let _dispose_decorators;\n  let _send_decorators;\n  let _subscribe_decorators;\n  let _addIntercepts_decorators;\n  let _end_decorators;\n  return class Session extends _classSuper {\n    static {\n      const _metadata = typeof Symbol === \"function\" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;\n      __esDecorate(this, null, _connection_decorators, {\n        kind: \"accessor\",\n        name: \"connection\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"connection\" in obj,\n          get: obj => obj.connection,\n          set: (obj, value) => {\n            obj.connection = value;\n          }\n        },\n        metadata: _metadata\n      }, _connection_initializers, _connection_extraInitializers);\n      __esDecorate(this, null, _dispose_decorators, {\n        kind: \"method\",\n        name: \"dispose\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"dispose\" in obj,\n          get: obj => obj.dispose\n        },\n        metadata: _metadata\n      }, null, _instanceExtraInitializers);\n      __esDecorate(this, null, _send_decorators, {\n        kind: \"method\",\n        name: \"send\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"send\" in obj,\n          get: obj => obj.send\n        },\n        metadata: _metadata\n      }, null, _instanceExtraInitializers);\n      __esDecorate(this, null, _subscribe_decorators, {\n        kind: \"method\",\n        name: \"subscribe\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"subscribe\" in obj,\n          get: obj => obj.subscribe\n        },\n        metadata: _metadata\n      }, null, _instanceExtraInitializers);\n      __esDecorate(this, null, _addIntercepts_decorators, {\n        kind: \"method\",\n        name: \"addIntercepts\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"addIntercepts\" in obj,\n          get: obj => obj.addIntercepts\n        },\n        metadata: _metadata\n      }, null, _instanceExtraInitializers);\n      __esDecorate(this, null, _end_decorators, {\n        kind: \"method\",\n        name: \"end\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"end\" in obj,\n          get: obj => obj.end\n        },\n        metadata: _metadata\n      }, null, _instanceExtraInitializers);\n      if (_metadata) Object.defineProperty(this, Symbol.metadata, {\n        enumerable: true,\n        configurable: true,\n        writable: true,\n        value: _metadata\n      });\n    }\n    static async from(connection, capabilities) {\n      const {\n        result\n      } = await connection.send('session.new', {\n        capabilities\n      });\n      const session = new Session(connection, result);\n      await session.#initialize();\n      return session;\n    }\n    #reason = __runInitializers(this, _instanceExtraInitializers);\n    #disposables = new disposable_js_1.DisposableStack();\n    #info;\n    browser;\n    #connection_accessor_storage = __runInitializers(this, _connection_initializers, void 0);\n    get connection() {\n      return this.#connection_accessor_storage;\n    }\n    set connection(value) {\n      this.#connection_accessor_storage = value;\n    }\n    constructor(connection, info) {\n      super();\n      __runInitializers(this, _connection_extraInitializers);\n      this.#info = info;\n      this.connection = connection;\n    }\n    async #initialize() {\n      // SAFETY: We use `any` to allow assignment of the readonly property.\n      this.browser = await Browser_js_1.Browser.from(this);\n      const browserEmitter = this.#disposables.use(this.browser);\n      browserEmitter.once('closed', ({\n        reason\n      }) => {\n        this.dispose(reason);\n      });\n      // TODO: Currently, some implementations do not emit navigationStarted event\n      // for fragment navigations (as per spec) and some do. This could emits a\n      // synthetic navigationStarted to work around this inconsistency.\n      const seen = new WeakSet();\n      this.on('browsingContext.fragmentNavigated', info => {\n        if (seen.has(info)) {\n          return;\n        }\n        seen.add(info);\n        this.emit('browsingContext.navigationStarted', info);\n        this.emit('browsingContext.fragmentNavigated', info);\n      });\n    }\n    get capabilities() {\n      return this.#info.capabilities;\n    }\n    get disposed() {\n      return this.ended;\n    }\n    get ended() {\n      return this.#reason !== undefined;\n    }\n    get id() {\n      return this.#info.sessionId;\n    }\n    dispose(reason) {\n      this.#reason = reason;\n      this[disposable_js_1.disposeSymbol]();\n    }\n    /**\n     * Currently, there is a 1:1 relationship between the session and the\n     * session. In the future, we might support multiple sessions and in that\n     * case we always needs to make sure that the session for the right session\n     * object is used, so we implement this method here, although it's not defined\n     * in the spec.\n     */\n    async send(method, params) {\n      return await this.connection.send(method, params);\n    }\n    async subscribe(events, contexts) {\n      await this.send('session.subscribe', {\n        events,\n        contexts\n      });\n    }\n    async addIntercepts(events, contexts) {\n      await this.send('session.subscribe', {\n        events,\n        contexts\n      });\n    }\n    async end() {\n      try {\n        await this.send('session.end', {});\n      } finally {\n        this.dispose(`Session already ended.`);\n      }\n    }\n    [(_connection_decorators = [(0, decorators_js_1.bubble)()], _dispose_decorators = [decorators_js_1.inertIfDisposed], _send_decorators = [(0, decorators_js_1.throwIfDisposed)(session => {\n      // SAFETY: By definition of `disposed`, `#reason` is defined.\n      return session.#reason;\n    })], _subscribe_decorators = [(0, decorators_js_1.throwIfDisposed)(session => {\n      // SAFETY: By definition of `disposed`, `#reason` is defined.\n      return session.#reason;\n    })], _addIntercepts_decorators = [(0, decorators_js_1.throwIfDisposed)(session => {\n      // SAFETY: By definition of `disposed`, `#reason` is defined.\n      return session.#reason;\n    })], _end_decorators = [(0, decorators_js_1.throwIfDisposed)(session => {\n      // SAFETY: By definition of `disposed`, `#reason` is defined.\n      return session.#reason;\n    })], disposable_js_1.disposeSymbol)]() {\n      this.#reason ??= 'Session already destroyed, probably because the connection broke.';\n      this.emit('ended', {\n        reason: this.#reason\n      });\n      this.#disposables.dispose();\n      super[disposable_js_1.disposeSymbol]();\n    }\n  };\n})();\nexports.Session = Session;","map":{"version":3,"names":["EventEmitter_js_1","require","decorators_js_1","disposable_js_1","Browser_js_1","Session","EventEmitter","_classSuper","__esDecorate","_connection_decorators","kind","name","static","private","access","has","obj","get","connection","set","value","metadata","_metadata","_connection_initializers","_connection_extraInitializers","_dispose_decorators","dispose","_instanceExtraInitializers","_send_decorators","send","_subscribe_decorators","subscribe","_addIntercepts_decorators","addIntercepts","_end_decorators","end","from","capabilities","result","session","initialize","reason","__runInitializers","disposables","DisposableStack","info","browser","connection_accessor_storage","constructor","#initialize","Browser","browserEmitter","use","once","seen","WeakSet","on","add","emit","disposed","ended","undefined","id","sessionId","disposeSymbol","method","params","events","contexts","bubble","inertIfDisposed","throwIfDisposed","exports"],"sources":["/Users/lawj4/webDevelopment/node_modules/puppeteer-core/src/bidi/core/Session.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2024 Google Inc.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport type * as Bidi from 'chromium-bidi/lib/cjs/protocol/protocol.js';\n\nimport {EventEmitter} from '../../common/EventEmitter.js';\nimport {\n  bubble,\n  inertIfDisposed,\n  throwIfDisposed,\n} from '../../util/decorators.js';\nimport {DisposableStack, disposeSymbol} from '../../util/disposable.js';\n\nimport {Browser} from './Browser.js';\nimport type {BidiEvents, Commands, Connection} from './Connection.js';\n\n/**\n * @internal\n */\nexport class Session\n  extends EventEmitter<BidiEvents & {ended: {reason: string}}>\n  implements Connection<BidiEvents & {ended: {reason: string}}>\n{\n  static async from(\n    connection: Connection,\n    capabilities: Bidi.Session.CapabilitiesRequest\n  ): Promise<Session> {\n    const {result} = await connection.send('session.new', {\n      capabilities,\n    });\n\n    const session = new Session(connection, result);\n    await session.#initialize();\n    return session;\n  }\n\n  #reason: string | undefined;\n  readonly #disposables = new DisposableStack();\n  readonly #info: Bidi.Session.NewResult;\n  readonly browser!: Browser;\n  @bubble()\n  accessor connection: Connection;\n\n  private constructor(connection: Connection, info: Bidi.Session.NewResult) {\n    super();\n\n    this.#info = info;\n    this.connection = connection;\n  }\n\n  async #initialize(): Promise<void> {\n    // SAFETY: We use `any` to allow assignment of the readonly property.\n    (this as any).browser = await Browser.from(this);\n\n    const browserEmitter = this.#disposables.use(this.browser);\n    browserEmitter.once('closed', ({reason}) => {\n      this.dispose(reason);\n    });\n\n    // TODO: Currently, some implementations do not emit navigationStarted event\n    // for fragment navigations (as per spec) and some do. This could emits a\n    // synthetic navigationStarted to work around this inconsistency.\n    const seen = new WeakSet();\n    this.on('browsingContext.fragmentNavigated', info => {\n      if (seen.has(info)) {\n        return;\n      }\n      seen.add(info);\n      this.emit('browsingContext.navigationStarted', info);\n      this.emit('browsingContext.fragmentNavigated', info);\n    });\n  }\n\n  get capabilities(): Bidi.Session.NewResult['capabilities'] {\n    return this.#info.capabilities;\n  }\n  get disposed(): boolean {\n    return this.ended;\n  }\n  get ended(): boolean {\n    return this.#reason !== undefined;\n  }\n  get id(): string {\n    return this.#info.sessionId;\n  }\n\n  @inertIfDisposed\n  private dispose(reason?: string): void {\n    this.#reason = reason;\n    this[disposeSymbol]();\n  }\n\n  /**\n   * Currently, there is a 1:1 relationship between the session and the\n   * session. In the future, we might support multiple sessions and in that\n   * case we always needs to make sure that the session for the right session\n   * object is used, so we implement this method here, although it's not defined\n   * in the spec.\n   */\n  @throwIfDisposed<Session>(session => {\n    // SAFETY: By definition of `disposed`, `#reason` is defined.\n    return session.#reason!;\n  })\n  async send<T extends keyof Commands>(\n    method: T,\n    params: Commands[T]['params']\n  ): Promise<{result: Commands[T]['returnType']}> {\n    return await this.connection.send(method, params);\n  }\n\n  @throwIfDisposed<Session>(session => {\n    // SAFETY: By definition of `disposed`, `#reason` is defined.\n    return session.#reason!;\n  })\n  async subscribe(\n    events: [string, ...string[]],\n    contexts?: [string, ...string[]]\n  ): Promise<void> {\n    await this.send('session.subscribe', {\n      events,\n      contexts,\n    });\n  }\n\n  @throwIfDisposed<Session>(session => {\n    // SAFETY: By definition of `disposed`, `#reason` is defined.\n    return session.#reason!;\n  })\n  async addIntercepts(\n    events: [string, ...string[]],\n    contexts?: [string, ...string[]]\n  ): Promise<void> {\n    await this.send('session.subscribe', {\n      events,\n      contexts,\n    });\n  }\n\n  @throwIfDisposed<Session>(session => {\n    // SAFETY: By definition of `disposed`, `#reason` is defined.\n    return session.#reason!;\n  })\n  async end(): Promise<void> {\n    try {\n      await this.send('session.end', {});\n    } finally {\n      this.dispose(`Session already ended.`);\n    }\n  }\n\n  [disposeSymbol](): void {\n    this.#reason ??=\n      'Session already destroyed, probably because the connection broke.';\n    this.emit('ended', {reason: this.#reason});\n\n    this.#disposables.dispose();\n    super[disposeSymbol]();\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}