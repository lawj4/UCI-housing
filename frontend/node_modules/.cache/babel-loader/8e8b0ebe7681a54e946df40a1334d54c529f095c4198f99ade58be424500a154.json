{"ast":null,"code":"\"use strict\";\n\n/*\n * Copyright 2023 Google LLC.\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ChannelProxy = void 0;\nconst protocol_js_1 = require(\"../../../protocol/protocol.js\");\nconst log_js_1 = require(\"../../../utils/log.js\");\nconst uuid_js_1 = require(\"../../../utils/uuid.js\");\n/**\n * Used to send messages from realm to BiDi user.\n */\nclass ChannelProxy {\n  #properties;\n  #id = (0, uuid_js_1.uuidv4)();\n  #logger;\n  constructor(channel, logger) {\n    this.#properties = channel;\n    this.#logger = logger;\n  }\n  /**\n   * Creates a channel proxy in the given realm, initialises listener and\n   * returns a handle to `sendMessage` delegate.\n   */\n  async init(realm, eventManager) {\n    const channelHandle = await ChannelProxy.#createAndGetHandleInRealm(realm);\n    const sendMessageHandle = await ChannelProxy.#createSendMessageHandle(realm, channelHandle);\n    void this.#startListener(realm, channelHandle, eventManager);\n    return sendMessageHandle;\n  }\n  /** Gets a ChannelProxy from window and returns its handle. */\n  async startListenerFromWindow(realm, eventManager) {\n    try {\n      const channelHandle = await this.#getHandleFromWindow(realm);\n      void this.#startListener(realm, channelHandle, eventManager);\n    } catch (error) {\n      this.#logger?.(log_js_1.LogType.debugError, error);\n    }\n  }\n  /**\n   * Evaluation string which creates a ChannelProxy object on the client side.\n   */\n  static #createChannelProxyEvalStr() {\n    const functionStr = String(() => {\n      const queue = [];\n      let queueNonEmptyResolver = null;\n      return {\n        /**\n         * Gets a promise, which is resolved as soon as a message occurs\n         * in the queue.\n         */\n        async getMessage() {\n          const onMessage = queue.length > 0 ? Promise.resolve() : new Promise(resolve => {\n            queueNonEmptyResolver = resolve;\n          });\n          await onMessage;\n          return queue.shift();\n        },\n        /**\n         * Adds a message to the queue.\n         * Resolves the pending promise if needed.\n         */\n        sendMessage(message) {\n          queue.push(message);\n          if (queueNonEmptyResolver !== null) {\n            queueNonEmptyResolver();\n            queueNonEmptyResolver = null;\n          }\n        }\n      };\n    });\n    return `(${functionStr})()`;\n  }\n  /** Creates a ChannelProxy in the given realm. */\n  static async #createAndGetHandleInRealm(realm) {\n    const createChannelHandleResult = await realm.cdpClient.sendCommand('Runtime.evaluate', {\n      expression: this.#createChannelProxyEvalStr(),\n      contextId: realm.executionContextId,\n      serializationOptions: {\n        serialization: \"idOnly\" /* Protocol.Runtime.SerializationOptionsSerialization.IdOnly */\n      }\n    });\n    if (createChannelHandleResult.exceptionDetails || createChannelHandleResult.result.objectId === undefined) {\n      throw new Error(`Cannot create channel`);\n    }\n    return createChannelHandleResult.result.objectId;\n  }\n  /** Gets a handle to `sendMessage` delegate from the ChannelProxy handle. */\n  static async #createSendMessageHandle(realm, channelHandle) {\n    const sendMessageArgResult = await realm.cdpClient.sendCommand('Runtime.callFunctionOn', {\n      functionDeclaration: String(channelHandle => {\n        return channelHandle.sendMessage;\n      }),\n      arguments: [{\n        objectId: channelHandle\n      }],\n      executionContextId: realm.executionContextId,\n      serializationOptions: {\n        serialization: \"idOnly\" /* Protocol.Runtime.SerializationOptionsSerialization.IdOnly */\n      }\n    });\n    // TODO: check for exceptionDetails.\n    return sendMessageArgResult.result.objectId;\n  }\n  /** Starts listening for the channel events of the provided ChannelProxy. */\n  async #startListener(realm, channelHandle, eventManager) {\n    // noinspection InfiniteLoopJS\n    for (;;) {\n      try {\n        const message = await realm.cdpClient.sendCommand('Runtime.callFunctionOn', {\n          functionDeclaration: String(async channelHandle => await channelHandle.getMessage()),\n          arguments: [{\n            objectId: channelHandle\n          }],\n          awaitPromise: true,\n          executionContextId: realm.executionContextId,\n          serializationOptions: {\n            serialization: \"deep\" /* Protocol.Runtime.SerializationOptionsSerialization.Deep */,\n            maxDepth: this.#properties.serializationOptions?.maxObjectDepth ?? undefined\n          }\n        });\n        if (message.exceptionDetails) {\n          throw new Error('Runtime.callFunctionOn in ChannelProxy', {\n            cause: message.exceptionDetails\n          });\n        }\n        for (const browsingContext of realm.associatedBrowsingContexts) {\n          eventManager.registerEvent({\n            type: 'event',\n            method: protocol_js_1.ChromiumBidi.Script.EventNames.Message,\n            params: {\n              channel: this.#properties.channel,\n              data: realm.cdpToBidiValue(message, this.#properties.ownership ?? \"none\" /* Script.ResultOwnership.None */),\n              source: realm.source\n            }\n          }, browsingContext.id);\n        }\n      } catch (error) {\n        // If an error is thrown, then the channel is permanently broken, so we\n        // exit the loop.\n        this.#logger?.(log_js_1.LogType.debugError, error);\n        break;\n      }\n    }\n  }\n  /**\n   * Returns a handle of ChannelProxy from window's property which was set there\n   * by `getEvalInWindowStr`. If window property is not set yet, sets a promise\n   * resolver to the window property, so that `getEvalInWindowStr` can resolve\n   * the promise later on with the channel.\n   * This is needed because `getEvalInWindowStr` can be called before or\n   * after this method.\n   */\n  async #getHandleFromWindow(realm) {\n    const channelHandleResult = await realm.cdpClient.sendCommand('Runtime.callFunctionOn', {\n      functionDeclaration: String(id => {\n        const w = window;\n        if (w[id] === undefined) {\n          // The channelProxy is not created yet. Create a promise, put the\n          // resolver to window property and return the promise.\n          // `getEvalInWindowStr` will resolve the promise later.\n          return new Promise(resolve => w[id] = resolve);\n        }\n        // The channelProxy is already created by `getEvalInWindowStr` and\n        // is set into window property. Return it.\n        const channelProxy = w[id];\n        delete w[id];\n        return channelProxy;\n      }),\n      arguments: [{\n        value: this.#id\n      }],\n      executionContextId: realm.executionContextId,\n      awaitPromise: true,\n      serializationOptions: {\n        serialization: \"idOnly\" /* Protocol.Runtime.SerializationOptionsSerialization.IdOnly */\n      }\n    });\n    if (channelHandleResult.exceptionDetails !== undefined || channelHandleResult.result.objectId === undefined) {\n      throw new Error(`ChannelHandle not found in window[\"${this.#id}\"]`);\n    }\n    return channelHandleResult.result.objectId;\n  }\n  /**\n   * String to be evaluated to create a ProxyChannel and put it to window.\n   * Returns the delegate `sendMessage`. Used to provide an argument for preload\n   * script. Does the following:\n   * 1. Creates a ChannelProxy.\n   * 2. Puts the ChannelProxy to window['${this.#id}'] or resolves the promise\n   *    by calling delegate stored in window['${this.#id}'].\n   *    This is needed because `#getHandleFromWindow` can be called before or\n   *    after this method.\n   * 3. Returns the delegate `sendMessage` of the created ChannelProxy.\n   */\n  getEvalInWindowStr() {\n    const delegate = String((id, channelProxy) => {\n      const w = window;\n      if (w[id] === undefined) {\n        // `#getHandleFromWindow` is not initialized yet, and will get the\n        // channelProxy later.\n        w[id] = channelProxy;\n      } else {\n        // `#getHandleFromWindow` is already set a delegate to window property\n        // and is waiting for it to be called with the channelProxy.\n        w[id](channelProxy);\n        delete w[id];\n      }\n      return channelProxy.sendMessage;\n    });\n    const channelProxyEval = ChannelProxy.#createChannelProxyEvalStr();\n    return `(${delegate})('${this.#id}',${channelProxyEval})`;\n  }\n}\nexports.ChannelProxy = ChannelProxy;","map":{"version":3,"names":["protocol_js_1","require","log_js_1","uuid_js_1","ChannelProxy","properties","id","uuidv4","logger","constructor","channel","init","realm","eventManager","channelHandle","createAndGetHandleInRealm","sendMessageHandle","createSendMessageHandle","startListener","startListenerFromWindow","getHandleFromWindow","error","LogType","debugError","createChannelProxyEvalStr","#createChannelProxyEvalStr","functionStr","String","queue","queueNonEmptyResolver","getMessage","onMessage","length","Promise","resolve","shift","sendMessage","message","push","#createAndGetHandleInRealm","createChannelHandleResult","cdpClient","sendCommand","expression","contextId","executionContextId","serializationOptions","serialization","exceptionDetails","result","objectId","undefined","Error","#createSendMessageHandle","sendMessageArgResult","functionDeclaration","arguments","#startListener","awaitPromise","maxDepth","maxObjectDepth","cause","browsingContext","associatedBrowsingContexts","registerEvent","type","method","ChromiumBidi","Script","EventNames","Message","params","data","cdpToBidiValue","ownership","source","#getHandleFromWindow","channelHandleResult","w","window","channelProxy","value","getEvalInWindowStr","delegate","channelProxyEval","exports"],"sources":["../../../../../src/bidiMapper/modules/script/ChannelProxy.ts"],"sourcesContent":[null],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}