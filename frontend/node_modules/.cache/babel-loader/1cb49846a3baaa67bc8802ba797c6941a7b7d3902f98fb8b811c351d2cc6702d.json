{"ast":null,"code":"\"use strict\";\n\nvar __addDisposableResource = this && this.__addDisposableResource || function (env, value, async) {\n  if (value !== null && value !== void 0) {\n    if (typeof value !== \"object\" && typeof value !== \"function\") throw new TypeError(\"Object expected.\");\n    var dispose;\n    if (async) {\n      if (!Symbol.asyncDispose) throw new TypeError(\"Symbol.asyncDispose is not defined.\");\n      dispose = value[Symbol.asyncDispose];\n    }\n    if (dispose === void 0) {\n      if (!Symbol.dispose) throw new TypeError(\"Symbol.dispose is not defined.\");\n      dispose = value[Symbol.dispose];\n    }\n    if (typeof dispose !== \"function\") throw new TypeError(\"Object not disposable.\");\n    env.stack.push({\n      value: value,\n      dispose: dispose,\n      async: async\n    });\n  } else if (async) {\n    env.stack.push({\n      async: true\n    });\n  }\n  return value;\n};\nvar __disposeResources = this && this.__disposeResources || function (SuppressedError) {\n  return function (env) {\n    function fail(e) {\n      env.error = env.hasError ? new SuppressedError(e, env.error, \"An error was suppressed during disposal.\") : e;\n      env.hasError = true;\n    }\n    function next() {\n      while (env.stack.length) {\n        var rec = env.stack.pop();\n        try {\n          var result = rec.dispose && rec.dispose.call(rec.value);\n          if (rec.async) return Promise.resolve(result).then(next, function (e) {\n            fail(e);\n            return next();\n          });\n        } catch (e) {\n          fail(e);\n        }\n      }\n      if (env.hasError) throw env.error;\n    }\n    return next();\n  };\n}(typeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\n  var e = new Error(message);\n  return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\n});\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.RETRY_DELAY = exports.RaceLocator = exports.NodeLocator = exports.MappedLocator = exports.FilteredLocator = exports.DelegatedLocator = exports.FunctionLocator = exports.Locator = exports.LocatorEvent = void 0;\nconst rxjs_js_1 = require(\"../../../third_party/rxjs/rxjs.js\");\nconst EventEmitter_js_1 = require(\"../../common/EventEmitter.js\");\nconst util_js_1 = require(\"../../common/util.js\");\n/**\n * All the events that a locator instance may emit.\n *\n * @public\n */\nvar LocatorEvent;\n(function (LocatorEvent) {\n  /**\n   * Emitted every time before the locator performs an action on the located element(s).\n   */\n  LocatorEvent[\"Action\"] = \"action\";\n})(LocatorEvent || (exports.LocatorEvent = LocatorEvent = {}));\n/**\n * Locators describe a strategy of locating objects and performing an action on\n * them. If the action fails because the object is not ready for the action, the\n * whole operation is retried. Various preconditions for a successful action are\n * checked automatically.\n *\n * See {@link https://pptr.dev/guides/page-interactions#locators} for details.\n *\n * @public\n */\nclass Locator extends EventEmitter_js_1.EventEmitter {\n  /**\n   * Creates a race between multiple locators trying to locate elements in\n   * parallel but ensures that only a single element receives the action.\n   *\n   * @public\n   */\n  static race(locators) {\n    return RaceLocator.create(locators);\n  }\n  /**\n   * @internal\n   */\n  visibility = null;\n  /**\n   * @internal\n   */\n  _timeout = 30000;\n  #ensureElementIsInTheViewport = true;\n  #waitForEnabled = true;\n  #waitForStableBoundingBox = true;\n  /**\n   * @internal\n   */\n  operators = {\n    conditions: (conditions, signal) => {\n      return (0, rxjs_js_1.mergeMap)(handle => {\n        return (0, rxjs_js_1.merge)(...conditions.map(condition => {\n          return condition(handle, signal);\n        })).pipe((0, rxjs_js_1.defaultIfEmpty)(handle));\n      });\n    },\n    retryAndRaceWithSignalAndTimer: (signal, cause) => {\n      const candidates = [];\n      if (signal) {\n        candidates.push((0, util_js_1.fromAbortSignal)(signal, cause));\n      }\n      candidates.push((0, util_js_1.timeout)(this._timeout, cause));\n      return (0, rxjs_js_1.pipe)((0, rxjs_js_1.retry)({\n        delay: exports.RETRY_DELAY\n      }), (0, rxjs_js_1.raceWith)(...candidates));\n    }\n  };\n  // Determines when the locator will timeout for actions.\n  get timeout() {\n    return this._timeout;\n  }\n  /**\n   * Creates a new locator instance by cloning the current locator and setting\n   * the total timeout for the locator actions.\n   *\n   * Pass `0` to disable timeout.\n   *\n   * @defaultValue `Page.getDefaultTimeout()`\n   */\n  setTimeout(timeout) {\n    const locator = this._clone();\n    locator._timeout = timeout;\n    return locator;\n  }\n  /**\n   * Creates a new locator instance by cloning the current locator with the\n   * visibility property changed to the specified value.\n   */\n  setVisibility(visibility) {\n    const locator = this._clone();\n    locator.visibility = visibility;\n    return locator;\n  }\n  /**\n   * Creates a new locator instance by cloning the current locator and\n   * specifying whether to wait for input elements to become enabled before the\n   * action. Applicable to `click` and `fill` actions.\n   *\n   * @defaultValue `true`\n   */\n  setWaitForEnabled(value) {\n    const locator = this._clone();\n    locator.#waitForEnabled = value;\n    return locator;\n  }\n  /**\n   * Creates a new locator instance by cloning the current locator and\n   * specifying whether the locator should scroll the element into viewport if\n   * it is not in the viewport already.\n   *\n   * @defaultValue `true`\n   */\n  setEnsureElementIsInTheViewport(value) {\n    const locator = this._clone();\n    locator.#ensureElementIsInTheViewport = value;\n    return locator;\n  }\n  /**\n   * Creates a new locator instance by cloning the current locator and\n   * specifying whether the locator has to wait for the element's bounding box\n   * to be same between two consecutive animation frames.\n   *\n   * @defaultValue `true`\n   */\n  setWaitForStableBoundingBox(value) {\n    const locator = this._clone();\n    locator.#waitForStableBoundingBox = value;\n    return locator;\n  }\n  /**\n   * @internal\n   */\n  copyOptions(locator) {\n    this._timeout = locator._timeout;\n    this.visibility = locator.visibility;\n    this.#waitForEnabled = locator.#waitForEnabled;\n    this.#ensureElementIsInTheViewport = locator.#ensureElementIsInTheViewport;\n    this.#waitForStableBoundingBox = locator.#waitForStableBoundingBox;\n    return this;\n  }\n  /**\n   * If the element has a \"disabled\" property, wait for the element to be\n   * enabled.\n   */\n  #waitForEnabledIfNeeded = (handle, signal) => {\n    if (!this.#waitForEnabled) {\n      return rxjs_js_1.EMPTY;\n    }\n    return (0, rxjs_js_1.from)(handle.frame.waitForFunction(element => {\n      if (!(element instanceof HTMLElement)) {\n        return true;\n      }\n      const isNativeFormControl = ['BUTTON', 'INPUT', 'SELECT', 'TEXTAREA', 'OPTION', 'OPTGROUP'].includes(element.nodeName);\n      return !isNativeFormControl || !element.hasAttribute('disabled');\n    }, {\n      timeout: this._timeout,\n      signal\n    }, handle)).pipe((0, rxjs_js_1.ignoreElements)());\n  };\n  /**\n   * Compares the bounding box of the element for two consecutive animation\n   * frames and waits till they are the same.\n   */\n  #waitForStableBoundingBoxIfNeeded = handle => {\n    if (!this.#waitForStableBoundingBox) {\n      return rxjs_js_1.EMPTY;\n    }\n    return (0, rxjs_js_1.defer)(() => {\n      // Note we don't use waitForFunction because that relies on RAF.\n      return (0, rxjs_js_1.from)(handle.evaluate(element => {\n        return new Promise(resolve => {\n          window.requestAnimationFrame(() => {\n            const rect1 = element.getBoundingClientRect();\n            window.requestAnimationFrame(() => {\n              const rect2 = element.getBoundingClientRect();\n              resolve([{\n                x: rect1.x,\n                y: rect1.y,\n                width: rect1.width,\n                height: rect1.height\n              }, {\n                x: rect2.x,\n                y: rect2.y,\n                width: rect2.width,\n                height: rect2.height\n              }]);\n            });\n          });\n        });\n      }));\n    }).pipe((0, rxjs_js_1.first)(([rect1, rect2]) => {\n      return rect1.x === rect2.x && rect1.y === rect2.y && rect1.width === rect2.width && rect1.height === rect2.height;\n    }), (0, rxjs_js_1.retry)({\n      delay: exports.RETRY_DELAY\n    }), (0, rxjs_js_1.ignoreElements)());\n  };\n  /**\n   * Checks if the element is in the viewport and auto-scrolls it if it is not.\n   */\n  #ensureElementIsInTheViewportIfNeeded = handle => {\n    if (!this.#ensureElementIsInTheViewport) {\n      return rxjs_js_1.EMPTY;\n    }\n    return (0, rxjs_js_1.from)(handle.isIntersectingViewport({\n      threshold: 0\n    })).pipe((0, rxjs_js_1.filter)(isIntersectingViewport => {\n      return !isIntersectingViewport;\n    }), (0, rxjs_js_1.mergeMap)(() => {\n      return (0, rxjs_js_1.from)(handle.scrollIntoView());\n    }), (0, rxjs_js_1.mergeMap)(() => {\n      return (0, rxjs_js_1.defer)(() => {\n        return (0, rxjs_js_1.from)(handle.isIntersectingViewport({\n          threshold: 0\n        }));\n      }).pipe((0, rxjs_js_1.first)(rxjs_js_1.identity), (0, rxjs_js_1.retry)({\n        delay: exports.RETRY_DELAY\n      }), (0, rxjs_js_1.ignoreElements)());\n    }));\n  };\n  #click(options) {\n    const signal = options?.signal;\n    const cause = new Error('Locator.click');\n    return this._wait(options).pipe(this.operators.conditions([this.#ensureElementIsInTheViewportIfNeeded, this.#waitForStableBoundingBoxIfNeeded, this.#waitForEnabledIfNeeded], signal), (0, rxjs_js_1.tap)(() => {\n      return this.emit(LocatorEvent.Action, undefined);\n    }), (0, rxjs_js_1.mergeMap)(handle => {\n      return (0, rxjs_js_1.from)(handle.click(options)).pipe((0, rxjs_js_1.catchError)(err => {\n        void handle.dispose().catch(util_js_1.debugError);\n        throw err;\n      }));\n    }), this.operators.retryAndRaceWithSignalAndTimer(signal, cause));\n  }\n  #fill(value, options) {\n    const signal = options?.signal;\n    const cause = new Error('Locator.fill');\n    return this._wait(options).pipe(this.operators.conditions([this.#ensureElementIsInTheViewportIfNeeded, this.#waitForStableBoundingBoxIfNeeded, this.#waitForEnabledIfNeeded], signal), (0, rxjs_js_1.tap)(() => {\n      return this.emit(LocatorEvent.Action, undefined);\n    }), (0, rxjs_js_1.mergeMap)(handle => {\n      return (0, rxjs_js_1.from)(handle.evaluate(el => {\n        if (el instanceof HTMLSelectElement) {\n          return 'select';\n        }\n        if (el instanceof HTMLTextAreaElement) {\n          return 'typeable-input';\n        }\n        if (el instanceof HTMLInputElement) {\n          if (new Set(['textarea', 'text', 'url', 'tel', 'search', 'password', 'number', 'email']).has(el.type)) {\n            return 'typeable-input';\n          } else {\n            return 'other-input';\n          }\n        }\n        if (el.isContentEditable) {\n          return 'contenteditable';\n        }\n        return 'unknown';\n      })).pipe((0, rxjs_js_1.mergeMap)(inputType => {\n        switch (inputType) {\n          case 'select':\n            return (0, rxjs_js_1.from)(handle.select(value).then(rxjs_js_1.noop));\n          case 'contenteditable':\n          case 'typeable-input':\n            return (0, rxjs_js_1.from)(handle.evaluate((input, newValue) => {\n              const currentValue = input.isContentEditable ? input.innerText : input.value;\n              // Clear the input if the current value does not match the filled\n              // out value.\n              if (newValue.length <= currentValue.length || !newValue.startsWith(input.value)) {\n                if (input.isContentEditable) {\n                  input.innerText = '';\n                } else {\n                  input.value = '';\n                }\n                return newValue;\n              }\n              const originalValue = input.isContentEditable ? input.innerText : input.value;\n              // If the value is partially filled out, only type the rest. Move\n              // cursor to the end of the common prefix.\n              if (input.isContentEditable) {\n                input.innerText = '';\n                input.innerText = originalValue;\n              } else {\n                input.value = '';\n                input.value = originalValue;\n              }\n              return newValue.substring(originalValue.length);\n            }, value)).pipe((0, rxjs_js_1.mergeMap)(textToType => {\n              return (0, rxjs_js_1.from)(handle.type(textToType));\n            }));\n          case 'other-input':\n            return (0, rxjs_js_1.from)(handle.focus()).pipe((0, rxjs_js_1.mergeMap)(() => {\n              return (0, rxjs_js_1.from)(handle.evaluate((input, value) => {\n                input.value = value;\n                input.dispatchEvent(new Event('input', {\n                  bubbles: true\n                }));\n                input.dispatchEvent(new Event('change', {\n                  bubbles: true\n                }));\n              }, value));\n            }));\n          case 'unknown':\n            throw new Error(`Element cannot be filled out.`);\n        }\n      })).pipe((0, rxjs_js_1.catchError)(err => {\n        void handle.dispose().catch(util_js_1.debugError);\n        throw err;\n      }));\n    }), this.operators.retryAndRaceWithSignalAndTimer(signal, cause));\n  }\n  #hover(options) {\n    const signal = options?.signal;\n    const cause = new Error('Locator.hover');\n    return this._wait(options).pipe(this.operators.conditions([this.#ensureElementIsInTheViewportIfNeeded, this.#waitForStableBoundingBoxIfNeeded], signal), (0, rxjs_js_1.tap)(() => {\n      return this.emit(LocatorEvent.Action, undefined);\n    }), (0, rxjs_js_1.mergeMap)(handle => {\n      return (0, rxjs_js_1.from)(handle.hover()).pipe((0, rxjs_js_1.catchError)(err => {\n        void handle.dispose().catch(util_js_1.debugError);\n        throw err;\n      }));\n    }), this.operators.retryAndRaceWithSignalAndTimer(signal, cause));\n  }\n  #scroll(options) {\n    const signal = options?.signal;\n    const cause = new Error('Locator.scroll');\n    return this._wait(options).pipe(this.operators.conditions([this.#ensureElementIsInTheViewportIfNeeded, this.#waitForStableBoundingBoxIfNeeded], signal), (0, rxjs_js_1.tap)(() => {\n      return this.emit(LocatorEvent.Action, undefined);\n    }), (0, rxjs_js_1.mergeMap)(handle => {\n      return (0, rxjs_js_1.from)(handle.evaluate((el, scrollTop, scrollLeft) => {\n        if (scrollTop !== undefined) {\n          el.scrollTop = scrollTop;\n        }\n        if (scrollLeft !== undefined) {\n          el.scrollLeft = scrollLeft;\n        }\n      }, options?.scrollTop, options?.scrollLeft)).pipe((0, rxjs_js_1.catchError)(err => {\n        void handle.dispose().catch(util_js_1.debugError);\n        throw err;\n      }));\n    }), this.operators.retryAndRaceWithSignalAndTimer(signal, cause));\n  }\n  /**\n   * Clones the locator.\n   */\n  clone() {\n    return this._clone();\n  }\n  /**\n   * Waits for the locator to get a handle from the page.\n   *\n   * @public\n   */\n  async waitHandle(options) {\n    const cause = new Error('Locator.waitHandle');\n    return await (0, rxjs_js_1.firstValueFrom)(this._wait(options).pipe(this.operators.retryAndRaceWithSignalAndTimer(options?.signal, cause)));\n  }\n  /**\n   * Waits for the locator to get the serialized value from the page.\n   *\n   * Note this requires the value to be JSON-serializable.\n   *\n   * @public\n   */\n  async wait(options) {\n    const env_1 = {\n      stack: [],\n      error: void 0,\n      hasError: false\n    };\n    try {\n      const handle = __addDisposableResource(env_1, await this.waitHandle(options), false);\n      return await handle.jsonValue();\n    } catch (e_1) {\n      env_1.error = e_1;\n      env_1.hasError = true;\n    } finally {\n      __disposeResources(env_1);\n    }\n  }\n  /**\n   * Maps the locator using the provided mapper.\n   *\n   * @public\n   */\n  map(mapper) {\n    return new MappedLocator(this._clone(), handle => {\n      // SAFETY: TypeScript cannot deduce the type.\n      return handle.evaluateHandle(mapper);\n    });\n  }\n  /**\n   * Creates an expectation that is evaluated against located values.\n   *\n   * If the expectations do not match, then the locator will retry.\n   *\n   * @public\n   */\n  filter(predicate) {\n    return new FilteredLocator(this._clone(), async (handle, signal) => {\n      await handle.frame.waitForFunction(predicate, {\n        signal,\n        timeout: this._timeout\n      }, handle);\n      return true;\n    });\n  }\n  /**\n   * Creates an expectation that is evaluated against located handles.\n   *\n   * If the expectations do not match, then the locator will retry.\n   *\n   * @internal\n   */\n  filterHandle(predicate) {\n    return new FilteredLocator(this._clone(), predicate);\n  }\n  /**\n   * Maps the locator using the provided mapper.\n   *\n   * @internal\n   */\n  mapHandle(mapper) {\n    return new MappedLocator(this._clone(), mapper);\n  }\n  /**\n   * Clicks the located element.\n   */\n  click(options) {\n    return (0, rxjs_js_1.firstValueFrom)(this.#click(options));\n  }\n  /**\n   * Fills out the input identified by the locator using the provided value. The\n   * type of the input is determined at runtime and the appropriate fill-out\n   * method is chosen based on the type. `contenteditable`, select, textarea and\n   * input elements are supported.\n   */\n  fill(value, options) {\n    return (0, rxjs_js_1.firstValueFrom)(this.#fill(value, options));\n  }\n  /**\n   * Hovers over the located element.\n   */\n  hover(options) {\n    return (0, rxjs_js_1.firstValueFrom)(this.#hover(options));\n  }\n  /**\n   * Scrolls the located element.\n   */\n  scroll(options) {\n    return (0, rxjs_js_1.firstValueFrom)(this.#scroll(options));\n  }\n}\nexports.Locator = Locator;\n/**\n * @internal\n */\nclass FunctionLocator extends Locator {\n  static create(pageOrFrame, func) {\n    return new FunctionLocator(pageOrFrame, func).setTimeout('getDefaultTimeout' in pageOrFrame ? pageOrFrame.getDefaultTimeout() : pageOrFrame.page().getDefaultTimeout());\n  }\n  #pageOrFrame;\n  #func;\n  constructor(pageOrFrame, func) {\n    super();\n    this.#pageOrFrame = pageOrFrame;\n    this.#func = func;\n  }\n  _clone() {\n    return new FunctionLocator(this.#pageOrFrame, this.#func);\n  }\n  _wait(options) {\n    const signal = options?.signal;\n    return (0, rxjs_js_1.defer)(() => {\n      return (0, rxjs_js_1.from)(this.#pageOrFrame.waitForFunction(this.#func, {\n        timeout: this.timeout,\n        signal\n      }));\n    }).pipe((0, rxjs_js_1.throwIfEmpty)());\n  }\n}\nexports.FunctionLocator = FunctionLocator;\n/**\n * @internal\n */\nclass DelegatedLocator extends Locator {\n  #delegate;\n  constructor(delegate) {\n    super();\n    this.#delegate = delegate;\n    this.copyOptions(this.#delegate);\n  }\n  get delegate() {\n    return this.#delegate;\n  }\n  setTimeout(timeout) {\n    const locator = super.setTimeout(timeout);\n    locator.#delegate = this.#delegate.setTimeout(timeout);\n    return locator;\n  }\n  setVisibility(visibility) {\n    const locator = super.setVisibility(visibility);\n    locator.#delegate = locator.#delegate.setVisibility(visibility);\n    return locator;\n  }\n  setWaitForEnabled(value) {\n    const locator = super.setWaitForEnabled(value);\n    locator.#delegate = this.#delegate.setWaitForEnabled(value);\n    return locator;\n  }\n  setEnsureElementIsInTheViewport(value) {\n    const locator = super.setEnsureElementIsInTheViewport(value);\n    locator.#delegate = this.#delegate.setEnsureElementIsInTheViewport(value);\n    return locator;\n  }\n  setWaitForStableBoundingBox(value) {\n    const locator = super.setWaitForStableBoundingBox(value);\n    locator.#delegate = this.#delegate.setWaitForStableBoundingBox(value);\n    return locator;\n  }\n}\nexports.DelegatedLocator = DelegatedLocator;\n/**\n * @internal\n */\nclass FilteredLocator extends DelegatedLocator {\n  #predicate;\n  constructor(base, predicate) {\n    super(base);\n    this.#predicate = predicate;\n  }\n  _clone() {\n    return new FilteredLocator(this.delegate.clone(), this.#predicate).copyOptions(this);\n  }\n  _wait(options) {\n    return this.delegate._wait(options).pipe((0, rxjs_js_1.mergeMap)(handle => {\n      return (0, rxjs_js_1.from)(Promise.resolve(this.#predicate(handle, options?.signal))).pipe((0, rxjs_js_1.filter)(value => {\n        return value;\n      }), (0, rxjs_js_1.map)(() => {\n        // SAFETY: It passed the predicate, so this is correct.\n        return handle;\n      }));\n    }), (0, rxjs_js_1.throwIfEmpty)());\n  }\n}\nexports.FilteredLocator = FilteredLocator;\n/**\n * @internal\n */\nclass MappedLocator extends DelegatedLocator {\n  #mapper;\n  constructor(base, mapper) {\n    super(base);\n    this.#mapper = mapper;\n  }\n  _clone() {\n    return new MappedLocator(this.delegate.clone(), this.#mapper).copyOptions(this);\n  }\n  _wait(options) {\n    return this.delegate._wait(options).pipe((0, rxjs_js_1.mergeMap)(handle => {\n      return (0, rxjs_js_1.from)(Promise.resolve(this.#mapper(handle, options?.signal)));\n    }));\n  }\n}\nexports.MappedLocator = MappedLocator;\n/**\n * @internal\n */\nclass NodeLocator extends Locator {\n  static create(pageOrFrame, selector) {\n    return new NodeLocator(pageOrFrame, selector).setTimeout('getDefaultTimeout' in pageOrFrame ? pageOrFrame.getDefaultTimeout() : pageOrFrame.page().getDefaultTimeout());\n  }\n  #pageOrFrame;\n  #selector;\n  constructor(pageOrFrame, selector) {\n    super();\n    this.#pageOrFrame = pageOrFrame;\n    this.#selector = selector;\n  }\n  /**\n   * Waits for the element to become visible or hidden. visibility === 'visible'\n   * means that the element has a computed style, the visibility property other\n   * than 'hidden' or 'collapse' and non-empty bounding box. visibility ===\n   * 'hidden' means the opposite of that.\n   */\n  #waitForVisibilityIfNeeded = handle => {\n    if (!this.visibility) {\n      return rxjs_js_1.EMPTY;\n    }\n    return (() => {\n      switch (this.visibility) {\n        case 'hidden':\n          return (0, rxjs_js_1.defer)(() => {\n            return (0, rxjs_js_1.from)(handle.isHidden());\n          });\n        case 'visible':\n          return (0, rxjs_js_1.defer)(() => {\n            return (0, rxjs_js_1.from)(handle.isVisible());\n          });\n      }\n    })().pipe((0, rxjs_js_1.first)(rxjs_js_1.identity), (0, rxjs_js_1.retry)({\n      delay: exports.RETRY_DELAY\n    }), (0, rxjs_js_1.ignoreElements)());\n  };\n  _clone() {\n    return new NodeLocator(this.#pageOrFrame, this.#selector).copyOptions(this);\n  }\n  _wait(options) {\n    const signal = options?.signal;\n    return (0, rxjs_js_1.defer)(() => {\n      return (0, rxjs_js_1.from)(this.#pageOrFrame.waitForSelector(this.#selector, {\n        visible: false,\n        timeout: this._timeout,\n        signal\n      }));\n    }).pipe((0, rxjs_js_1.filter)(value => {\n      return value !== null;\n    }), (0, rxjs_js_1.throwIfEmpty)(), this.operators.conditions([this.#waitForVisibilityIfNeeded], signal));\n  }\n}\nexports.NodeLocator = NodeLocator;\nfunction checkLocatorArray(locators) {\n  for (const locator of locators) {\n    if (!(locator instanceof Locator)) {\n      throw new Error('Unknown locator for race candidate');\n    }\n  }\n  return locators;\n}\n/**\n * @internal\n */\nclass RaceLocator extends Locator {\n  static create(locators) {\n    const array = checkLocatorArray(locators);\n    return new RaceLocator(array);\n  }\n  #locators;\n  constructor(locators) {\n    super();\n    this.#locators = locators;\n  }\n  _clone() {\n    return new RaceLocator(this.#locators.map(locator => {\n      return locator.clone();\n    })).copyOptions(this);\n  }\n  _wait(options) {\n    return (0, rxjs_js_1.race)(...this.#locators.map(locator => {\n      return locator._wait(options);\n    }));\n  }\n}\nexports.RaceLocator = RaceLocator;\n/**\n * For observables coming from promises, a delay is needed, otherwise RxJS will\n * never yield in a permanent failure for a promise.\n *\n * We also don't want RxJS to do promise operations to often, so we bump the\n * delay up to 100ms.\n *\n * @internal\n */\nexports.RETRY_DELAY = 100;","map":{"version":3,"names":["rxjs_js_1","require","EventEmitter_js_1","util_js_1","LocatorEvent","exports","Locator","EventEmitter","race","locators","RaceLocator","create","visibility","_timeout","ensureElementIsInTheViewport","waitForEnabled","waitForStableBoundingBox","operators","conditions","signal","mergeMap","handle","merge","map","condition","pipe","defaultIfEmpty","retryAndRaceWithSignalAndTimer","cause","candidates","push","fromAbortSignal","timeout","retry","delay","RETRY_DELAY","raceWith","setTimeout","locator","_clone","setVisibility","setWaitForEnabled","value","setEnsureElementIsInTheViewport","setWaitForStableBoundingBox","copyOptions","waitForEnabledIfNeeded","#waitForEnabledIfNeeded","EMPTY","from","frame","waitForFunction","element","HTMLElement","isNativeFormControl","includes","nodeName","hasAttribute","ignoreElements","waitForStableBoundingBoxIfNeeded","defer","evaluate","Promise","resolve","window","requestAnimationFrame","rect1","getBoundingClientRect","rect2","x","y","width","height","first","ensureElementIsInTheViewportIfNeeded","isIntersectingViewport","threshold","filter","scrollIntoView","identity","click","#click","options","Error","_wait","tap","emit","Action","undefined","catchError","err","dispose","catch","debugError","fill","#fill","el","HTMLSelectElement","HTMLTextAreaElement","HTMLInputElement","Set","has","type","isContentEditable","inputType","select","then","noop","input","newValue","currentValue","innerText","length","startsWith","originalValue","substring","textToType","focus","dispatchEvent","Event","bubbles","hover","#hover","scroll","#scroll","scrollTop","scrollLeft","clone","waitHandle","firstValueFrom","wait","__addDisposableResource","env_1","jsonValue","mapper","MappedLocator","evaluateHandle","predicate","FilteredLocator","filterHandle","mapHandle","FunctionLocator","pageOrFrame","func","getDefaultTimeout","page","constructor","throwIfEmpty","DelegatedLocator","delegate","base","NodeLocator","selector","waitForVisibilityIfNeeded","isHidden","isVisible","waitForSelector","visible","checkLocatorArray","array"],"sources":["/Users/lawj4/webDevelopment/node_modules/puppeteer-core/src/api/locators/locators.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2023 Google Inc.\n * SPDX-License-Identifier: Apache-2.0\n */\nimport type {\n  Observable,\n  OperatorFunction,\n} from '../../../third_party/rxjs/rxjs.js';\nimport {\n  EMPTY,\n  catchError,\n  defaultIfEmpty,\n  defer,\n  filter,\n  first,\n  firstValueFrom,\n  from,\n  identity,\n  ignoreElements,\n  map,\n  merge,\n  mergeMap,\n  noop,\n  pipe,\n  race,\n  raceWith,\n  retry,\n  tap,\n  throwIfEmpty,\n} from '../../../third_party/rxjs/rxjs.js';\nimport type {EventType} from '../../common/EventEmitter.js';\nimport {EventEmitter} from '../../common/EventEmitter.js';\nimport type {Awaitable, HandleFor, NodeFor} from '../../common/types.js';\nimport {debugError, fromAbortSignal, timeout} from '../../common/util.js';\nimport type {\n  BoundingBox,\n  ClickOptions,\n  ElementHandle,\n} from '../ElementHandle.js';\nimport type {Frame} from '../Frame.js';\nimport type {Page} from '../Page.js';\n\n/**\n * Whether to wait for the element to be\n * {@link ElementHandle.isVisible | visible} or\n * {@link ElementHandle.isHidden | hidden}.\n * `null` to disable visibility checks.\n *\n * @public\n */\nexport type VisibilityOption = 'hidden' | 'visible' | null;\n\n/**\n * @public\n */\nexport interface ActionOptions {\n  /**\n   * A signal to abort the locator action.\n   */\n  signal?: AbortSignal;\n}\n/**\n * @public\n */\nexport type LocatorClickOptions = ClickOptions & ActionOptions;\n/**\n * @public\n */\nexport interface LocatorScrollOptions extends ActionOptions {\n  scrollTop?: number;\n  scrollLeft?: number;\n}\n/**\n * All the events that a locator instance may emit.\n *\n * @public\n */\nexport enum LocatorEvent {\n  /**\n   * Emitted every time before the locator performs an action on the located element(s).\n   */\n  Action = 'action',\n}\n\n/**\n * @public\n */\nexport interface LocatorEvents extends Record<EventType, unknown> {\n  [LocatorEvent.Action]: undefined;\n}\n\n/**\n * Locators describe a strategy of locating objects and performing an action on\n * them. If the action fails because the object is not ready for the action, the\n * whole operation is retried. Various preconditions for a successful action are\n * checked automatically.\n *\n * See {@link https://pptr.dev/guides/page-interactions#locators} for details.\n *\n * @public\n */\nexport abstract class Locator<T> extends EventEmitter<LocatorEvents> {\n  /**\n   * Creates a race between multiple locators trying to locate elements in\n   * parallel but ensures that only a single element receives the action.\n   *\n   * @public\n   */\n  static race<Locators extends readonly unknown[] | []>(\n    locators: Locators\n  ): Locator<AwaitedLocator<Locators[number]>> {\n    return RaceLocator.create(locators);\n  }\n\n  /**\n   * Used for nominally typing {@link Locator}.\n   */\n  declare _?: T;\n\n  /**\n   * @internal\n   */\n  protected visibility: VisibilityOption = null;\n  /**\n   * @internal\n   */\n  protected _timeout = 30000;\n  #ensureElementIsInTheViewport = true;\n  #waitForEnabled = true;\n  #waitForStableBoundingBox = true;\n\n  /**\n   * @internal\n   */\n  protected operators = {\n    conditions: (\n      conditions: Array<Action<T, never>>,\n      signal?: AbortSignal\n    ): OperatorFunction<HandleFor<T>, HandleFor<T>> => {\n      return mergeMap((handle: HandleFor<T>) => {\n        return merge(\n          ...conditions.map(condition => {\n            return condition(handle, signal);\n          })\n        ).pipe(defaultIfEmpty(handle));\n      });\n    },\n    retryAndRaceWithSignalAndTimer: <T>(\n      signal?: AbortSignal,\n      cause?: Error\n    ): OperatorFunction<T, T> => {\n      const candidates = [];\n      if (signal) {\n        candidates.push(fromAbortSignal(signal, cause));\n      }\n      candidates.push(timeout(this._timeout, cause));\n      return pipe(\n        retry({delay: RETRY_DELAY}),\n        raceWith<T, never[]>(...candidates)\n      );\n    },\n  };\n\n  // Determines when the locator will timeout for actions.\n  get timeout(): number {\n    return this._timeout;\n  }\n\n  /**\n   * Creates a new locator instance by cloning the current locator and setting\n   * the total timeout for the locator actions.\n   *\n   * Pass `0` to disable timeout.\n   *\n   * @defaultValue `Page.getDefaultTimeout()`\n   */\n  setTimeout(timeout: number): Locator<T> {\n    const locator = this._clone();\n    locator._timeout = timeout;\n    return locator;\n  }\n\n  /**\n   * Creates a new locator instance by cloning the current locator with the\n   * visibility property changed to the specified value.\n   */\n  setVisibility<NodeType extends Node>(\n    this: Locator<NodeType>,\n    visibility: VisibilityOption\n  ): Locator<NodeType> {\n    const locator = this._clone();\n    locator.visibility = visibility;\n    return locator;\n  }\n\n  /**\n   * Creates a new locator instance by cloning the current locator and\n   * specifying whether to wait for input elements to become enabled before the\n   * action. Applicable to `click` and `fill` actions.\n   *\n   * @defaultValue `true`\n   */\n  setWaitForEnabled<NodeType extends Node>(\n    this: Locator<NodeType>,\n    value: boolean\n  ): Locator<NodeType> {\n    const locator = this._clone();\n    locator.#waitForEnabled = value;\n    return locator;\n  }\n\n  /**\n   * Creates a new locator instance by cloning the current locator and\n   * specifying whether the locator should scroll the element into viewport if\n   * it is not in the viewport already.\n   *\n   * @defaultValue `true`\n   */\n  setEnsureElementIsInTheViewport<ElementType extends Element>(\n    this: Locator<ElementType>,\n    value: boolean\n  ): Locator<ElementType> {\n    const locator = this._clone();\n    locator.#ensureElementIsInTheViewport = value;\n    return locator;\n  }\n\n  /**\n   * Creates a new locator instance by cloning the current locator and\n   * specifying whether the locator has to wait for the element's bounding box\n   * to be same between two consecutive animation frames.\n   *\n   * @defaultValue `true`\n   */\n  setWaitForStableBoundingBox<ElementType extends Element>(\n    this: Locator<ElementType>,\n    value: boolean\n  ): Locator<ElementType> {\n    const locator = this._clone();\n    locator.#waitForStableBoundingBox = value;\n    return locator;\n  }\n\n  /**\n   * @internal\n   */\n  copyOptions<T>(locator: Locator<T>): this {\n    this._timeout = locator._timeout;\n    this.visibility = locator.visibility;\n    this.#waitForEnabled = locator.#waitForEnabled;\n    this.#ensureElementIsInTheViewport = locator.#ensureElementIsInTheViewport;\n    this.#waitForStableBoundingBox = locator.#waitForStableBoundingBox;\n    return this;\n  }\n\n  /**\n   * If the element has a \"disabled\" property, wait for the element to be\n   * enabled.\n   */\n  #waitForEnabledIfNeeded = <ElementType extends Node>(\n    handle: HandleFor<ElementType>,\n    signal?: AbortSignal\n  ): Observable<never> => {\n    if (!this.#waitForEnabled) {\n      return EMPTY;\n    }\n    return from(\n      handle.frame.waitForFunction(\n        element => {\n          if (!(element instanceof HTMLElement)) {\n            return true;\n          }\n          const isNativeFormControl = [\n            'BUTTON',\n            'INPUT',\n            'SELECT',\n            'TEXTAREA',\n            'OPTION',\n            'OPTGROUP',\n          ].includes(element.nodeName);\n          return !isNativeFormControl || !element.hasAttribute('disabled');\n        },\n        {\n          timeout: this._timeout,\n          signal,\n        },\n        handle\n      )\n    ).pipe(ignoreElements());\n  };\n\n  /**\n   * Compares the bounding box of the element for two consecutive animation\n   * frames and waits till they are the same.\n   */\n  #waitForStableBoundingBoxIfNeeded = <ElementType extends Element>(\n    handle: HandleFor<ElementType>\n  ): Observable<never> => {\n    if (!this.#waitForStableBoundingBox) {\n      return EMPTY;\n    }\n    return defer(() => {\n      // Note we don't use waitForFunction because that relies on RAF.\n      return from(\n        handle.evaluate(element => {\n          return new Promise<[BoundingBox, BoundingBox]>(resolve => {\n            window.requestAnimationFrame(() => {\n              const rect1 = element.getBoundingClientRect();\n              window.requestAnimationFrame(() => {\n                const rect2 = element.getBoundingClientRect();\n                resolve([\n                  {\n                    x: rect1.x,\n                    y: rect1.y,\n                    width: rect1.width,\n                    height: rect1.height,\n                  },\n                  {\n                    x: rect2.x,\n                    y: rect2.y,\n                    width: rect2.width,\n                    height: rect2.height,\n                  },\n                ]);\n              });\n            });\n          });\n        })\n      );\n    }).pipe(\n      first(([rect1, rect2]) => {\n        return (\n          rect1.x === rect2.x &&\n          rect1.y === rect2.y &&\n          rect1.width === rect2.width &&\n          rect1.height === rect2.height\n        );\n      }),\n      retry({delay: RETRY_DELAY}),\n      ignoreElements()\n    );\n  };\n\n  /**\n   * Checks if the element is in the viewport and auto-scrolls it if it is not.\n   */\n  #ensureElementIsInTheViewportIfNeeded = <ElementType extends Element>(\n    handle: HandleFor<ElementType>\n  ): Observable<never> => {\n    if (!this.#ensureElementIsInTheViewport) {\n      return EMPTY;\n    }\n    return from(handle.isIntersectingViewport({threshold: 0})).pipe(\n      filter(isIntersectingViewport => {\n        return !isIntersectingViewport;\n      }),\n      mergeMap(() => {\n        return from(handle.scrollIntoView());\n      }),\n      mergeMap(() => {\n        return defer(() => {\n          return from(handle.isIntersectingViewport({threshold: 0}));\n        }).pipe(first(identity), retry({delay: RETRY_DELAY}), ignoreElements());\n      })\n    );\n  };\n\n  #click<ElementType extends Element>(\n    this: Locator<ElementType>,\n    options?: Readonly<LocatorClickOptions>\n  ): Observable<void> {\n    const signal = options?.signal;\n    const cause = new Error('Locator.click');\n    return this._wait(options).pipe(\n      this.operators.conditions(\n        [\n          this.#ensureElementIsInTheViewportIfNeeded,\n          this.#waitForStableBoundingBoxIfNeeded,\n          this.#waitForEnabledIfNeeded,\n        ],\n        signal\n      ),\n      tap(() => {\n        return this.emit(LocatorEvent.Action, undefined);\n      }),\n      mergeMap(handle => {\n        return from(handle.click(options)).pipe(\n          catchError(err => {\n            void handle.dispose().catch(debugError);\n            throw err;\n          })\n        );\n      }),\n      this.operators.retryAndRaceWithSignalAndTimer(signal, cause)\n    );\n  }\n\n  #fill<ElementType extends Element>(\n    this: Locator<ElementType>,\n    value: string,\n    options?: Readonly<ActionOptions>\n  ): Observable<void> {\n    const signal = options?.signal;\n    const cause = new Error('Locator.fill');\n    return this._wait(options).pipe(\n      this.operators.conditions(\n        [\n          this.#ensureElementIsInTheViewportIfNeeded,\n          this.#waitForStableBoundingBoxIfNeeded,\n          this.#waitForEnabledIfNeeded,\n        ],\n        signal\n      ),\n      tap(() => {\n        return this.emit(LocatorEvent.Action, undefined);\n      }),\n      mergeMap(handle => {\n        return from(\n          (handle as unknown as ElementHandle<HTMLElement>).evaluate(el => {\n            if (el instanceof HTMLSelectElement) {\n              return 'select';\n            }\n            if (el instanceof HTMLTextAreaElement) {\n              return 'typeable-input';\n            }\n            if (el instanceof HTMLInputElement) {\n              if (\n                new Set([\n                  'textarea',\n                  'text',\n                  'url',\n                  'tel',\n                  'search',\n                  'password',\n                  'number',\n                  'email',\n                ]).has(el.type)\n              ) {\n                return 'typeable-input';\n              } else {\n                return 'other-input';\n              }\n            }\n\n            if (el.isContentEditable) {\n              return 'contenteditable';\n            }\n\n            return 'unknown';\n          })\n        )\n          .pipe(\n            mergeMap(inputType => {\n              switch (inputType) {\n                case 'select':\n                  return from(handle.select(value).then(noop));\n                case 'contenteditable':\n                case 'typeable-input':\n                  return from(\n                    (\n                      handle as unknown as ElementHandle<HTMLInputElement>\n                    ).evaluate((input, newValue) => {\n                      const currentValue = input.isContentEditable\n                        ? input.innerText\n                        : input.value;\n\n                      // Clear the input if the current value does not match the filled\n                      // out value.\n                      if (\n                        newValue.length <= currentValue.length ||\n                        !newValue.startsWith(input.value)\n                      ) {\n                        if (input.isContentEditable) {\n                          input.innerText = '';\n                        } else {\n                          input.value = '';\n                        }\n                        return newValue;\n                      }\n                      const originalValue = input.isContentEditable\n                        ? input.innerText\n                        : input.value;\n\n                      // If the value is partially filled out, only type the rest. Move\n                      // cursor to the end of the common prefix.\n                      if (input.isContentEditable) {\n                        input.innerText = '';\n                        input.innerText = originalValue;\n                      } else {\n                        input.value = '';\n                        input.value = originalValue;\n                      }\n                      return newValue.substring(originalValue.length);\n                    }, value)\n                  ).pipe(\n                    mergeMap(textToType => {\n                      return from(handle.type(textToType));\n                    })\n                  );\n                case 'other-input':\n                  return from(handle.focus()).pipe(\n                    mergeMap(() => {\n                      return from(\n                        handle.evaluate((input, value) => {\n                          (input as HTMLInputElement).value = value;\n                          input.dispatchEvent(\n                            new Event('input', {bubbles: true})\n                          );\n                          input.dispatchEvent(\n                            new Event('change', {bubbles: true})\n                          );\n                        }, value)\n                      );\n                    })\n                  );\n                case 'unknown':\n                  throw new Error(`Element cannot be filled out.`);\n              }\n            })\n          )\n          .pipe(\n            catchError(err => {\n              void handle.dispose().catch(debugError);\n              throw err;\n            })\n          );\n      }),\n      this.operators.retryAndRaceWithSignalAndTimer(signal, cause)\n    );\n  }\n\n  #hover<ElementType extends Element>(\n    this: Locator<ElementType>,\n    options?: Readonly<ActionOptions>\n  ): Observable<void> {\n    const signal = options?.signal;\n    const cause = new Error('Locator.hover');\n    return this._wait(options).pipe(\n      this.operators.conditions(\n        [\n          this.#ensureElementIsInTheViewportIfNeeded,\n          this.#waitForStableBoundingBoxIfNeeded,\n        ],\n        signal\n      ),\n      tap(() => {\n        return this.emit(LocatorEvent.Action, undefined);\n      }),\n      mergeMap(handle => {\n        return from(handle.hover()).pipe(\n          catchError(err => {\n            void handle.dispose().catch(debugError);\n            throw err;\n          })\n        );\n      }),\n      this.operators.retryAndRaceWithSignalAndTimer(signal, cause)\n    );\n  }\n\n  #scroll<ElementType extends Element>(\n    this: Locator<ElementType>,\n    options?: Readonly<LocatorScrollOptions>\n  ): Observable<void> {\n    const signal = options?.signal;\n    const cause = new Error('Locator.scroll');\n    return this._wait(options).pipe(\n      this.operators.conditions(\n        [\n          this.#ensureElementIsInTheViewportIfNeeded,\n          this.#waitForStableBoundingBoxIfNeeded,\n        ],\n        signal\n      ),\n      tap(() => {\n        return this.emit(LocatorEvent.Action, undefined);\n      }),\n      mergeMap(handle => {\n        return from(\n          handle.evaluate(\n            (el, scrollTop, scrollLeft) => {\n              if (scrollTop !== undefined) {\n                el.scrollTop = scrollTop;\n              }\n              if (scrollLeft !== undefined) {\n                el.scrollLeft = scrollLeft;\n              }\n            },\n            options?.scrollTop,\n            options?.scrollLeft\n          )\n        ).pipe(\n          catchError(err => {\n            void handle.dispose().catch(debugError);\n            throw err;\n          })\n        );\n      }),\n      this.operators.retryAndRaceWithSignalAndTimer(signal, cause)\n    );\n  }\n\n  /**\n   * @internal\n   */\n  abstract _clone(): Locator<T>;\n\n  /**\n   * @internal\n   */\n  abstract _wait(options?: Readonly<ActionOptions>): Observable<HandleFor<T>>;\n\n  /**\n   * Clones the locator.\n   */\n  clone(): Locator<T> {\n    return this._clone();\n  }\n\n  /**\n   * Waits for the locator to get a handle from the page.\n   *\n   * @public\n   */\n  async waitHandle(options?: Readonly<ActionOptions>): Promise<HandleFor<T>> {\n    const cause = new Error('Locator.waitHandle');\n    return await firstValueFrom(\n      this._wait(options).pipe(\n        this.operators.retryAndRaceWithSignalAndTimer(options?.signal, cause)\n      )\n    );\n  }\n\n  /**\n   * Waits for the locator to get the serialized value from the page.\n   *\n   * Note this requires the value to be JSON-serializable.\n   *\n   * @public\n   */\n  async wait(options?: Readonly<ActionOptions>): Promise<T> {\n    using handle = await this.waitHandle(options);\n    return await handle.jsonValue();\n  }\n\n  /**\n   * Maps the locator using the provided mapper.\n   *\n   * @public\n   */\n  map<To>(mapper: Mapper<T, To>): Locator<To> {\n    return new MappedLocator(this._clone(), handle => {\n      // SAFETY: TypeScript cannot deduce the type.\n      return (handle as any).evaluateHandle(mapper);\n    });\n  }\n\n  /**\n   * Creates an expectation that is evaluated against located values.\n   *\n   * If the expectations do not match, then the locator will retry.\n   *\n   * @public\n   */\n  filter<S extends T>(predicate: Predicate<T, S>): Locator<S> {\n    return new FilteredLocator(this._clone(), async (handle, signal) => {\n      await (handle as ElementHandle<Node>).frame.waitForFunction(\n        predicate,\n        {signal, timeout: this._timeout},\n        handle\n      );\n      return true;\n    });\n  }\n\n  /**\n   * Creates an expectation that is evaluated against located handles.\n   *\n   * If the expectations do not match, then the locator will retry.\n   *\n   * @internal\n   */\n  filterHandle<S extends T>(\n    predicate: Predicate<HandleFor<T>, HandleFor<S>>\n  ): Locator<S> {\n    return new FilteredLocator(this._clone(), predicate);\n  }\n\n  /**\n   * Maps the locator using the provided mapper.\n   *\n   * @internal\n   */\n  mapHandle<To>(mapper: HandleMapper<T, To>): Locator<To> {\n    return new MappedLocator(this._clone(), mapper);\n  }\n\n  /**\n   * Clicks the located element.\n   */\n  click<ElementType extends Element>(\n    this: Locator<ElementType>,\n    options?: Readonly<LocatorClickOptions>\n  ): Promise<void> {\n    return firstValueFrom(this.#click(options));\n  }\n\n  /**\n   * Fills out the input identified by the locator using the provided value. The\n   * type of the input is determined at runtime and the appropriate fill-out\n   * method is chosen based on the type. `contenteditable`, select, textarea and\n   * input elements are supported.\n   */\n  fill<ElementType extends Element>(\n    this: Locator<ElementType>,\n    value: string,\n    options?: Readonly<ActionOptions>\n  ): Promise<void> {\n    return firstValueFrom(this.#fill(value, options));\n  }\n\n  /**\n   * Hovers over the located element.\n   */\n  hover<ElementType extends Element>(\n    this: Locator<ElementType>,\n    options?: Readonly<ActionOptions>\n  ): Promise<void> {\n    return firstValueFrom(this.#hover(options));\n  }\n\n  /**\n   * Scrolls the located element.\n   */\n  scroll<ElementType extends Element>(\n    this: Locator<ElementType>,\n    options?: Readonly<LocatorScrollOptions>\n  ): Promise<void> {\n    return firstValueFrom(this.#scroll(options));\n  }\n}\n\n/**\n * @internal\n */\nexport class FunctionLocator<T> extends Locator<T> {\n  static create<Ret>(\n    pageOrFrame: Page | Frame,\n    func: () => Awaitable<Ret>\n  ): Locator<Ret> {\n    return new FunctionLocator<Ret>(pageOrFrame, func).setTimeout(\n      'getDefaultTimeout' in pageOrFrame\n        ? pageOrFrame.getDefaultTimeout()\n        : pageOrFrame.page().getDefaultTimeout()\n    );\n  }\n\n  #pageOrFrame: Page | Frame;\n  #func: () => Awaitable<T>;\n\n  private constructor(pageOrFrame: Page | Frame, func: () => Awaitable<T>) {\n    super();\n\n    this.#pageOrFrame = pageOrFrame;\n    this.#func = func;\n  }\n\n  override _clone(): FunctionLocator<T> {\n    return new FunctionLocator(this.#pageOrFrame, this.#func);\n  }\n\n  _wait(options?: Readonly<ActionOptions>): Observable<HandleFor<T>> {\n    const signal = options?.signal;\n    return defer(() => {\n      return from(\n        this.#pageOrFrame.waitForFunction(this.#func, {\n          timeout: this.timeout,\n          signal,\n        })\n      );\n    }).pipe(throwIfEmpty());\n  }\n}\n\n/**\n * @public\n */\nexport type Predicate<From, To extends From = From> =\n  | ((value: From) => value is To)\n  | ((value: From) => Awaitable<boolean>);\n/**\n * @internal\n */\nexport type HandlePredicate<From, To extends From = From> =\n  | ((value: HandleFor<From>, signal?: AbortSignal) => value is HandleFor<To>)\n  | ((value: HandleFor<From>, signal?: AbortSignal) => Awaitable<boolean>);\n\n/**\n * @internal\n */\nexport abstract class DelegatedLocator<T, U> extends Locator<U> {\n  #delegate: Locator<T>;\n\n  constructor(delegate: Locator<T>) {\n    super();\n\n    this.#delegate = delegate;\n    this.copyOptions(this.#delegate);\n  }\n\n  protected get delegate(): Locator<T> {\n    return this.#delegate;\n  }\n\n  override setTimeout(timeout: number): DelegatedLocator<T, U> {\n    const locator = super.setTimeout(timeout) as DelegatedLocator<T, U>;\n    locator.#delegate = this.#delegate.setTimeout(timeout);\n    return locator;\n  }\n\n  override setVisibility<ValueType extends Node, NodeType extends Node>(\n    this: DelegatedLocator<ValueType, NodeType>,\n    visibility: VisibilityOption\n  ): DelegatedLocator<ValueType, NodeType> {\n    const locator = super.setVisibility<NodeType>(\n      visibility\n    ) as DelegatedLocator<ValueType, NodeType>;\n    locator.#delegate = locator.#delegate.setVisibility<ValueType>(visibility);\n    return locator;\n  }\n\n  override setWaitForEnabled<ValueType extends Node, NodeType extends Node>(\n    this: DelegatedLocator<ValueType, NodeType>,\n    value: boolean\n  ): DelegatedLocator<ValueType, NodeType> {\n    const locator = super.setWaitForEnabled<NodeType>(\n      value\n    ) as DelegatedLocator<ValueType, NodeType>;\n    locator.#delegate = this.#delegate.setWaitForEnabled(value);\n    return locator;\n  }\n\n  override setEnsureElementIsInTheViewport<\n    ValueType extends Element,\n    ElementType extends Element,\n  >(\n    this: DelegatedLocator<ValueType, ElementType>,\n    value: boolean\n  ): DelegatedLocator<ValueType, ElementType> {\n    const locator = super.setEnsureElementIsInTheViewport<ElementType>(\n      value\n    ) as DelegatedLocator<ValueType, ElementType>;\n    locator.#delegate = this.#delegate.setEnsureElementIsInTheViewport(value);\n    return locator;\n  }\n\n  override setWaitForStableBoundingBox<\n    ValueType extends Element,\n    ElementType extends Element,\n  >(\n    this: DelegatedLocator<ValueType, ElementType>,\n    value: boolean\n  ): DelegatedLocator<ValueType, ElementType> {\n    const locator = super.setWaitForStableBoundingBox<ElementType>(\n      value\n    ) as DelegatedLocator<ValueType, ElementType>;\n    locator.#delegate = this.#delegate.setWaitForStableBoundingBox(value);\n    return locator;\n  }\n\n  abstract override _clone(): DelegatedLocator<T, U>;\n  abstract override _wait(): Observable<HandleFor<U>>;\n}\n\n/**\n * @internal\n */\nexport class FilteredLocator<From, To extends From> extends DelegatedLocator<\n  From,\n  To\n> {\n  #predicate: HandlePredicate<From, To>;\n\n  constructor(base: Locator<From>, predicate: HandlePredicate<From, To>) {\n    super(base);\n    this.#predicate = predicate;\n  }\n\n  override _clone(): FilteredLocator<From, To> {\n    return new FilteredLocator(\n      this.delegate.clone(),\n      this.#predicate\n    ).copyOptions(this);\n  }\n\n  override _wait(options?: Readonly<ActionOptions>): Observable<HandleFor<To>> {\n    return this.delegate._wait(options).pipe(\n      mergeMap(handle => {\n        return from(\n          Promise.resolve(this.#predicate(handle, options?.signal))\n        ).pipe(\n          filter(value => {\n            return value;\n          }),\n          map(() => {\n            // SAFETY: It passed the predicate, so this is correct.\n            return handle as HandleFor<To>;\n          })\n        );\n      }),\n      throwIfEmpty()\n    );\n  }\n}\n\n/**\n * @public\n */\nexport type Mapper<From, To> = (value: From) => Awaitable<To>;\n/**\n * @internal\n */\nexport type HandleMapper<From, To> = (\n  value: HandleFor<From>,\n  signal?: AbortSignal\n) => Awaitable<HandleFor<To>>;\n/**\n * @internal\n */\nexport class MappedLocator<From, To> extends DelegatedLocator<From, To> {\n  #mapper: HandleMapper<From, To>;\n\n  constructor(base: Locator<From>, mapper: HandleMapper<From, To>) {\n    super(base);\n    this.#mapper = mapper;\n  }\n\n  override _clone(): MappedLocator<From, To> {\n    return new MappedLocator(this.delegate.clone(), this.#mapper).copyOptions(\n      this\n    );\n  }\n\n  override _wait(options?: Readonly<ActionOptions>): Observable<HandleFor<To>> {\n    return this.delegate._wait(options).pipe(\n      mergeMap(handle => {\n        return from(Promise.resolve(this.#mapper(handle, options?.signal)));\n      })\n    );\n  }\n}\n\n/**\n * @internal\n */\nexport type Action<T, U> = (\n  element: HandleFor<T>,\n  signal?: AbortSignal\n) => Observable<U>;\n/**\n * @internal\n */\nexport class NodeLocator<T extends Node> extends Locator<T> {\n  static create<Selector extends string>(\n    pageOrFrame: Page | Frame,\n    selector: Selector\n  ): Locator<NodeFor<Selector>> {\n    return new NodeLocator<NodeFor<Selector>>(pageOrFrame, selector).setTimeout(\n      'getDefaultTimeout' in pageOrFrame\n        ? pageOrFrame.getDefaultTimeout()\n        : pageOrFrame.page().getDefaultTimeout()\n    );\n  }\n\n  #pageOrFrame: Page | Frame;\n  #selector: string;\n\n  private constructor(pageOrFrame: Page | Frame, selector: string) {\n    super();\n\n    this.#pageOrFrame = pageOrFrame;\n    this.#selector = selector;\n  }\n\n  /**\n   * Waits for the element to become visible or hidden. visibility === 'visible'\n   * means that the element has a computed style, the visibility property other\n   * than 'hidden' or 'collapse' and non-empty bounding box. visibility ===\n   * 'hidden' means the opposite of that.\n   */\n  #waitForVisibilityIfNeeded = (handle: HandleFor<T>): Observable<never> => {\n    if (!this.visibility) {\n      return EMPTY;\n    }\n\n    return (() => {\n      switch (this.visibility) {\n        case 'hidden':\n          return defer(() => {\n            return from(handle.isHidden());\n          });\n        case 'visible':\n          return defer(() => {\n            return from(handle.isVisible());\n          });\n      }\n    })().pipe(first(identity), retry({delay: RETRY_DELAY}), ignoreElements());\n  };\n\n  override _clone(): NodeLocator<T> {\n    return new NodeLocator<T>(this.#pageOrFrame, this.#selector).copyOptions(\n      this\n    );\n  }\n\n  override _wait(options?: Readonly<ActionOptions>): Observable<HandleFor<T>> {\n    const signal = options?.signal;\n    return defer(() => {\n      return from(\n        this.#pageOrFrame.waitForSelector(this.#selector, {\n          visible: false,\n          timeout: this._timeout,\n          signal,\n        }) as Promise<HandleFor<T> | null>\n      );\n    }).pipe(\n      filter((value): value is NonNullable<typeof value> => {\n        return value !== null;\n      }),\n      throwIfEmpty(),\n      this.operators.conditions([this.#waitForVisibilityIfNeeded], signal)\n    );\n  }\n}\n\n/**\n * @public\n */\nexport type AwaitedLocator<T> = T extends Locator<infer S> ? S : never;\nfunction checkLocatorArray<T extends readonly unknown[] | []>(\n  locators: T\n): ReadonlyArray<Locator<AwaitedLocator<T[number]>>> {\n  for (const locator of locators) {\n    if (!(locator instanceof Locator)) {\n      throw new Error('Unknown locator for race candidate');\n    }\n  }\n  return locators as ReadonlyArray<Locator<AwaitedLocator<T[number]>>>;\n}\n/**\n * @internal\n */\nexport class RaceLocator<T> extends Locator<T> {\n  static create<T extends readonly unknown[]>(\n    locators: T\n  ): Locator<AwaitedLocator<T[number]>> {\n    const array = checkLocatorArray(locators);\n    return new RaceLocator(array);\n  }\n\n  #locators: ReadonlyArray<Locator<T>>;\n\n  constructor(locators: ReadonlyArray<Locator<T>>) {\n    super();\n    this.#locators = locators;\n  }\n\n  override _clone(): RaceLocator<T> {\n    return new RaceLocator<T>(\n      this.#locators.map(locator => {\n        return locator.clone();\n      })\n    ).copyOptions(this);\n  }\n\n  override _wait(options?: Readonly<ActionOptions>): Observable<HandleFor<T>> {\n    return race(\n      ...this.#locators.map(locator => {\n        return locator._wait(options);\n      })\n    );\n  }\n}\n\n/**\n * For observables coming from promises, a delay is needed, otherwise RxJS will\n * never yield in a permanent failure for a promise.\n *\n * We also don't want RxJS to do promise operations to often, so we bump the\n * delay up to 100ms.\n *\n * @internal\n */\nexport const RETRY_DELAY = 100;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}