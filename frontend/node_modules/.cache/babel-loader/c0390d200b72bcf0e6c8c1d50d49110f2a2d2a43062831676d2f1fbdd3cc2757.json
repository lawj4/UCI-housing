{"ast":null,"code":"\"use strict\";\n\n/**\n * @license\n * Copyright 2017 Google Inc.\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.BrowserContext = void 0;\nconst rxjs_js_1 = require(\"../../third_party/rxjs/rxjs.js\");\nconst EventEmitter_js_1 = require(\"../common/EventEmitter.js\");\nconst util_js_1 = require(\"../common/util.js\");\nconst disposable_js_1 = require(\"../util/disposable.js\");\nconst Mutex_js_1 = require(\"../util/Mutex.js\");\n/**\n * {@link BrowserContext} represents individual user contexts within a\n * {@link Browser | browser}.\n *\n * When a {@link Browser | browser} is launched, it has at least one default\n * {@link BrowserContext | browser context}. Others can be created\n * using {@link Browser.createBrowserContext}. Each context has isolated storage\n * (cookies/localStorage/etc.)\n *\n * {@link BrowserContext} {@link EventEmitter | emits} various events which are\n * documented in the {@link BrowserContextEvent} enum.\n *\n * If a {@link Page | page} opens another {@link Page | page}, e.g. using\n * `window.open`, the popup will belong to the parent {@link Page.browserContext\n * | page's browser context}.\n *\n * @example Creating a new {@link BrowserContext | browser context}:\n *\n * ```ts\n * // Create a new browser context\n * const context = await browser.createBrowserContext();\n * // Create a new page inside context.\n * const page = await context.newPage();\n * // ... do stuff with page ...\n * await page.goto('https://example.com');\n * // Dispose context once it's no longer needed.\n * await context.close();\n * ```\n *\n * @remarks\n *\n * In Chrome all non-default contexts are incognito,\n * and {@link Browser.defaultBrowserContext | default browser context}\n * might be incognito if you provide the `--incognito` argument when launching\n * the browser.\n *\n * @public\n */\nclass BrowserContext extends EventEmitter_js_1.EventEmitter {\n  /**\n   * @internal\n   */\n  constructor() {\n    super();\n  }\n  /**\n   * If defined, indicates an ongoing screenshot opereation.\n   */\n  #pageScreenshotMutex;\n  #screenshotOperationsCount = 0;\n  /**\n   * @internal\n   */\n  startScreenshot() {\n    const mutex = this.#pageScreenshotMutex || new Mutex_js_1.Mutex();\n    this.#pageScreenshotMutex = mutex;\n    this.#screenshotOperationsCount++;\n    return mutex.acquire(() => {\n      this.#screenshotOperationsCount--;\n      if (this.#screenshotOperationsCount === 0) {\n        // Remove the mutex to indicate no ongoing screenshot operation.\n        this.#pageScreenshotMutex = undefined;\n      }\n    });\n  }\n  /**\n   * @internal\n   */\n  waitForScreenshotOperations() {\n    return this.#pageScreenshotMutex?.acquire();\n  }\n  /**\n   * Waits until a {@link Target | target} matching the given `predicate`\n   * appears and returns it.\n   *\n   * This will look all open {@link BrowserContext | browser contexts}.\n   *\n   * @example Finding a target for a page opened via `window.open`:\n   *\n   * ```ts\n   * await page.evaluate(() => window.open('https://www.example.com/'));\n   * const newWindowTarget = await browserContext.waitForTarget(\n   *   target => target.url() === 'https://www.example.com/'\n   * );\n   * ```\n   */\n  async waitForTarget(predicate, options = {}) {\n    const {\n      timeout: ms = 30000\n    } = options;\n    return await (0, rxjs_js_1.firstValueFrom)((0, rxjs_js_1.merge)((0, util_js_1.fromEmitterEvent)(this, \"targetcreated\" /* BrowserContextEvent.TargetCreated */), (0, util_js_1.fromEmitterEvent)(this, \"targetchanged\" /* BrowserContextEvent.TargetChanged */), (0, rxjs_js_1.from)(this.targets())).pipe((0, util_js_1.filterAsync)(predicate), (0, rxjs_js_1.raceWith)((0, util_js_1.timeout)(ms))));\n  }\n  /**\n   * Whether this {@link BrowserContext | browser context} is closed.\n   */\n  get closed() {\n    return !this.browser().browserContexts().includes(this);\n  }\n  /**\n   * Identifier for this {@link BrowserContext | browser context}.\n   */\n  get id() {\n    return undefined;\n  }\n  /** @internal */\n  [disposable_js_1.disposeSymbol]() {\n    return void this.close().catch(util_js_1.debugError);\n  }\n  /** @internal */\n  [disposable_js_1.asyncDisposeSymbol]() {\n    return this.close();\n  }\n}\nexports.BrowserContext = BrowserContext;","map":{"version":3,"names":["rxjs_js_1","require","EventEmitter_js_1","util_js_1","disposable_js_1","Mutex_js_1","BrowserContext","EventEmitter","constructor","pageScreenshotMutex","screenshotOperationsCount","startScreenshot","mutex","Mutex","acquire","undefined","waitForScreenshotOperations","waitForTarget","predicate","options","timeout","ms","firstValueFrom","merge","fromEmitterEvent","from","targets","pipe","filterAsync","raceWith","closed","browser","browserContexts","includes","id","disposeSymbol","close","catch","debugError","asyncDisposeSymbol","exports"],"sources":["/Users/lawj4/webDevelopment/Todo-List/frontend/node_modules/puppeteer-core/src/api/BrowserContext.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2017 Google Inc.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport {\n  firstValueFrom,\n  from,\n  merge,\n  raceWith,\n} from '../../third_party/rxjs/rxjs.js';\nimport {EventEmitter, type EventType} from '../common/EventEmitter.js';\nimport {\n  debugError,\n  fromEmitterEvent,\n  filterAsync,\n  timeout,\n} from '../common/util.js';\nimport {asyncDisposeSymbol, disposeSymbol} from '../util/disposable.js';\nimport {Mutex} from '../util/Mutex.js';\n\nimport type {Browser, Permission, WaitForTargetOptions} from './Browser.js';\nimport type {Page} from './Page.js';\nimport type {Target} from './Target.js';\n\n/**\n * @public\n */\nexport const enum BrowserContextEvent {\n  /**\n   * Emitted when the url of a target inside the browser context changes.\n   * Contains a {@link Target} instance.\n   */\n  TargetChanged = 'targetchanged',\n\n  /**\n   * Emitted when a target is created within the browser context, for example\n   * when a new page is opened by\n   * {@link https://developer.mozilla.org/en-US/docs/Web/API/Window/open | window.open}\n   * or by {@link BrowserContext.newPage | browserContext.newPage}\n   *\n   * Contains a {@link Target} instance.\n   */\n  TargetCreated = 'targetcreated',\n  /**\n   * Emitted when a target is destroyed within the browser context, for example\n   * when a page is closed. Contains a {@link Target} instance.\n   */\n  TargetDestroyed = 'targetdestroyed',\n}\n\n/**\n * @public\n */\nexport interface BrowserContextEvents extends Record<EventType, unknown> {\n  [BrowserContextEvent.TargetChanged]: Target;\n  [BrowserContextEvent.TargetCreated]: Target;\n  [BrowserContextEvent.TargetDestroyed]: Target;\n}\n\n/**\n * {@link BrowserContext} represents individual user contexts within a\n * {@link Browser | browser}.\n *\n * When a {@link Browser | browser} is launched, it has at least one default\n * {@link BrowserContext | browser context}. Others can be created\n * using {@link Browser.createBrowserContext}. Each context has isolated storage\n * (cookies/localStorage/etc.)\n *\n * {@link BrowserContext} {@link EventEmitter | emits} various events which are\n * documented in the {@link BrowserContextEvent} enum.\n *\n * If a {@link Page | page} opens another {@link Page | page}, e.g. using\n * `window.open`, the popup will belong to the parent {@link Page.browserContext\n * | page's browser context}.\n *\n * @example Creating a new {@link BrowserContext | browser context}:\n *\n * ```ts\n * // Create a new browser context\n * const context = await browser.createBrowserContext();\n * // Create a new page inside context.\n * const page = await context.newPage();\n * // ... do stuff with page ...\n * await page.goto('https://example.com');\n * // Dispose context once it's no longer needed.\n * await context.close();\n * ```\n *\n * @remarks\n *\n * In Chrome all non-default contexts are incognito,\n * and {@link Browser.defaultBrowserContext | default browser context}\n * might be incognito if you provide the `--incognito` argument when launching\n * the browser.\n *\n * @public\n */\n\nexport abstract class BrowserContext extends EventEmitter<BrowserContextEvents> {\n  /**\n   * @internal\n   */\n  constructor() {\n    super();\n  }\n\n  /**\n   * Gets all active {@link Target | targets} inside this\n   * {@link BrowserContext | browser context}.\n   */\n  abstract targets(): Target[];\n\n  /**\n   * If defined, indicates an ongoing screenshot opereation.\n   */\n  #pageScreenshotMutex?: Mutex;\n  #screenshotOperationsCount = 0;\n\n  /**\n   * @internal\n   */\n  startScreenshot(): Promise<InstanceType<typeof Mutex.Guard>> {\n    const mutex = this.#pageScreenshotMutex || new Mutex();\n    this.#pageScreenshotMutex = mutex;\n    this.#screenshotOperationsCount++;\n    return mutex.acquire(() => {\n      this.#screenshotOperationsCount--;\n      if (this.#screenshotOperationsCount === 0) {\n        // Remove the mutex to indicate no ongoing screenshot operation.\n        this.#pageScreenshotMutex = undefined;\n      }\n    });\n  }\n\n  /**\n   * @internal\n   */\n  waitForScreenshotOperations():\n    | Promise<InstanceType<typeof Mutex.Guard>>\n    | undefined {\n    return this.#pageScreenshotMutex?.acquire();\n  }\n\n  /**\n   * Waits until a {@link Target | target} matching the given `predicate`\n   * appears and returns it.\n   *\n   * This will look all open {@link BrowserContext | browser contexts}.\n   *\n   * @example Finding a target for a page opened via `window.open`:\n   *\n   * ```ts\n   * await page.evaluate(() => window.open('https://www.example.com/'));\n   * const newWindowTarget = await browserContext.waitForTarget(\n   *   target => target.url() === 'https://www.example.com/'\n   * );\n   * ```\n   */\n  async waitForTarget(\n    predicate: (x: Target) => boolean | Promise<boolean>,\n    options: WaitForTargetOptions = {}\n  ): Promise<Target> {\n    const {timeout: ms = 30000} = options;\n    return await firstValueFrom(\n      merge(\n        fromEmitterEvent(this, BrowserContextEvent.TargetCreated),\n        fromEmitterEvent(this, BrowserContextEvent.TargetChanged),\n        from(this.targets())\n      ).pipe(filterAsync(predicate), raceWith(timeout(ms)))\n    );\n  }\n\n  /**\n   * Gets a list of all open {@link Page | pages} inside this\n   * {@link BrowserContext | browser context}.\n   *\n   * @remarks Non-visible {@link Page | pages}, such as `\"background_page\"`,\n   * will not be listed here. You can find them using {@link Target.page}.\n   */\n  abstract pages(): Promise<Page[]>;\n\n  /**\n   * Grants this {@link BrowserContext | browser context} the given\n   * `permissions` within the given `origin`.\n   *\n   * @example Overriding permissions in the\n   * {@link Browser.defaultBrowserContext | default browser context}:\n   *\n   * ```ts\n   * const context = browser.defaultBrowserContext();\n   * await context.overridePermissions('https://html5demos.com', [\n   *   'geolocation',\n   * ]);\n   * ```\n   *\n   * @param origin - The origin to grant permissions to, e.g.\n   * \"https://example.com\".\n   * @param permissions - An array of permissions to grant. All permissions that\n   * are not listed here will be automatically denied.\n   */\n  abstract overridePermissions(\n    origin: string,\n    permissions: Permission[]\n  ): Promise<void>;\n\n  /**\n   * Clears all permission overrides for this\n   * {@link BrowserContext | browser context}.\n   *\n   * @example Clearing overridden permissions in the\n   * {@link Browser.defaultBrowserContext | default browser context}:\n   *\n   * ```ts\n   * const context = browser.defaultBrowserContext();\n   * context.overridePermissions('https://example.com', ['clipboard-read']);\n   * // do stuff ..\n   * context.clearPermissionOverrides();\n   * ```\n   */\n  abstract clearPermissionOverrides(): Promise<void>;\n\n  /**\n   * Creates a new {@link Page | page} in this\n   * {@link BrowserContext | browser context}.\n   */\n  abstract newPage(): Promise<Page>;\n\n  /**\n   * Gets the {@link Browser | browser} associated with this\n   * {@link BrowserContext | browser context}.\n   */\n  abstract browser(): Browser;\n\n  /**\n   * Closes this {@link BrowserContext | browser context} and all associated\n   * {@link Page | pages}.\n   *\n   * @remarks The\n   * {@link Browser.defaultBrowserContext | default browser context} cannot be\n   * closed.\n   */\n  abstract close(): Promise<void>;\n\n  /**\n   * Whether this {@link BrowserContext | browser context} is closed.\n   */\n  get closed(): boolean {\n    return !this.browser().browserContexts().includes(this);\n  }\n\n  /**\n   * Identifier for this {@link BrowserContext | browser context}.\n   */\n  get id(): string | undefined {\n    return undefined;\n  }\n\n  /** @internal */\n  [disposeSymbol](): void {\n    return void this.close().catch(debugError);\n  }\n\n  /** @internal */\n  [asyncDisposeSymbol](): Promise<void> {\n    return this.close();\n  }\n}\n"],"mappings":";;AAAA;;;;;;;;;AAMA,MAAAA,SAAA,GAAAC,OAAA;AAMA,MAAAC,iBAAA,GAAAD,OAAA;AACA,MAAAE,SAAA,GAAAF,OAAA;AAMA,MAAAG,eAAA,GAAAH,OAAA;AACA,MAAAI,UAAA,GAAAJ,OAAA;AAyCA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAuCA,MAAsBK,cAAe,SAAQJ,iBAAA,CAAAK,YAAkC;EAC7E;;;EAGAC,YAAA;IACE,KAAK,EAAE;EACT;EAQA;;;EAGA,CAAAC,mBAAoB;EACpB,CAAAC,yBAA0B,GAAG,CAAC;EAE9B;;;EAGAC,eAAeA,CAAA;IACb,MAAMC,KAAK,GAAG,IAAI,CAAC,CAAAH,mBAAoB,IAAI,IAAIJ,UAAA,CAAAQ,KAAK,EAAE;IACtD,IAAI,CAAC,CAAAJ,mBAAoB,GAAGG,KAAK;IACjC,IAAI,CAAC,CAAAF,yBAA0B,EAAE;IACjC,OAAOE,KAAK,CAACE,OAAO,CAAC,MAAK;MACxB,IAAI,CAAC,CAAAJ,yBAA0B,EAAE;MACjC,IAAI,IAAI,CAAC,CAAAA,yBAA0B,KAAK,CAAC,EAAE;QACzC;QACA,IAAI,CAAC,CAAAD,mBAAoB,GAAGM,SAAS;MACvC;IACF,CAAC,CAAC;EACJ;EAEA;;;EAGAC,2BAA2BA,CAAA;IAGzB,OAAO,IAAI,CAAC,CAAAP,mBAAoB,EAAEK,OAAO,EAAE;EAC7C;EAEA;;;;;;;;;;;;;;;EAeA,MAAMG,aAAaA,CACjBC,SAAoD,EACpDC,OAAA,GAAgC,EAAE;IAElC,MAAM;MAACC,OAAO,EAAEC,EAAE,GAAG;IAAK,CAAC,GAAGF,OAAO;IACrC,OAAO,MAAM,IAAAnB,SAAA,CAAAsB,cAAc,EACzB,IAAAtB,SAAA,CAAAuB,KAAK,EACH,IAAApB,SAAA,CAAAqB,gBAAgB,EAAC,IAAI,0DAAoC,EACzD,IAAArB,SAAA,CAAAqB,gBAAgB,EAAC,IAAI,0DAAoC,EACzD,IAAAxB,SAAA,CAAAyB,IAAI,EAAC,IAAI,CAACC,OAAO,EAAE,CAAC,CACrB,CAACC,IAAI,CAAC,IAAAxB,SAAA,CAAAyB,WAAW,EAACV,SAAS,CAAC,EAAE,IAAAlB,SAAA,CAAA6B,QAAQ,EAAC,IAAA1B,SAAA,CAAAiB,OAAO,EAACC,EAAE,CAAC,CAAC,CAAC,CACtD;EACH;EAyEA;;;EAGA,IAAIS,MAAMA,CAAA;IACR,OAAO,CAAC,IAAI,CAACC,OAAO,EAAE,CAACC,eAAe,EAAE,CAACC,QAAQ,CAAC,IAAI,CAAC;EACzD;EAEA;;;EAGA,IAAIC,EAAEA,CAAA;IACJ,OAAOnB,SAAS;EAClB;EAEA;EACA,CAACX,eAAA,CAAA+B,aAAa,IAAC;IACb,OAAO,KAAK,IAAI,CAACC,KAAK,EAAE,CAACC,KAAK,CAAClC,SAAA,CAAAmC,UAAU,CAAC;EAC5C;EAEA;EACA,CAAClC,eAAA,CAAAmC,kBAAkB,IAAC;IAClB,OAAO,IAAI,CAACH,KAAK,EAAE;EACrB;;AAvKFI,OAAA,CAAAlC,cAAA,GAAAA,cAAA","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}