{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.PipeTransport = void 0;\nconst EventEmitter_js_1 = require(\"../common/EventEmitter.js\");\nconst util_js_1 = require(\"../common/util.js\");\nconst assert_js_1 = require(\"../util/assert.js\");\nconst disposable_js_1 = require(\"../util/disposable.js\");\n/**\n * @internal\n */\nclass PipeTransport {\n  #pipeWrite;\n  #subscriptions = new disposable_js_1.DisposableStack();\n  #isClosed = false;\n  #pendingMessage = '';\n  onclose;\n  onmessage;\n  constructor(pipeWrite, pipeRead) {\n    this.#pipeWrite = pipeWrite;\n    const pipeReadEmitter = this.#subscriptions.use(\n    // NodeJS event emitters don't support `*` so we need to typecast\n    // As long as we don't use it we should be OK.\n    new EventEmitter_js_1.EventEmitter(pipeRead));\n    pipeReadEmitter.on('data', buffer => {\n      return this.#dispatch(buffer);\n    });\n    pipeReadEmitter.on('close', () => {\n      if (this.onclose) {\n        this.onclose.call(null);\n      }\n    });\n    pipeReadEmitter.on('error', util_js_1.debugError);\n    const pipeWriteEmitter = this.#subscriptions.use(\n    // NodeJS event emitters don't support `*` so we need to typecast\n    // As long as we don't use it we should be OK.\n    new EventEmitter_js_1.EventEmitter(pipeRead));\n    pipeWriteEmitter.on('error', util_js_1.debugError);\n  }\n  send(message) {\n    (0, assert_js_1.assert)(!this.#isClosed, '`PipeTransport` is closed.');\n    this.#pipeWrite.write(message);\n    this.#pipeWrite.write('\\0');\n  }\n  #dispatch(buffer) {\n    (0, assert_js_1.assert)(!this.#isClosed, '`PipeTransport` is closed.');\n    let end = buffer.indexOf('\\0');\n    if (end === -1) {\n      this.#pendingMessage += buffer.toString();\n      return;\n    }\n    const message = this.#pendingMessage + buffer.toString(undefined, 0, end);\n    if (this.onmessage) {\n      this.onmessage.call(null, message);\n    }\n    let start = end + 1;\n    end = buffer.indexOf('\\0', start);\n    while (end !== -1) {\n      if (this.onmessage) {\n        this.onmessage.call(null, buffer.toString(undefined, start, end));\n      }\n      start = end + 1;\n      end = buffer.indexOf('\\0', start);\n    }\n    this.#pendingMessage = buffer.toString(undefined, start);\n  }\n  close() {\n    this.#isClosed = true;\n    this.#subscriptions.dispose();\n  }\n}\nexports.PipeTransport = PipeTransport;","map":{"version":3,"names":["EventEmitter_js_1","require","util_js_1","assert_js_1","disposable_js_1","PipeTransport","pipeWrite","subscriptions","DisposableStack","isClosed","pendingMessage","onclose","onmessage","constructor","pipeRead","pipeReadEmitter","use","EventEmitter","on","buffer","dispatch","call","debugError","pipeWriteEmitter","send","message","assert","write","#dispatch","end","indexOf","toString","undefined","start","close","dispose","exports"],"sources":["/Users/lawj4/webDevelopment/Todo-List/frontend/node_modules/puppeteer-core/src/node/PipeTransport.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2018 Google Inc.\n * SPDX-License-Identifier: Apache-2.0\n */\nimport type {ConnectionTransport} from '../common/ConnectionTransport.js';\nimport {EventEmitter} from '../common/EventEmitter.js';\nimport {debugError} from '../common/util.js';\nimport {assert} from '../util/assert.js';\nimport {DisposableStack} from '../util/disposable.js';\n\n/**\n * @internal\n */\nexport class PipeTransport implements ConnectionTransport {\n  #pipeWrite: NodeJS.WritableStream;\n  #subscriptions = new DisposableStack();\n\n  #isClosed = false;\n  #pendingMessage = '';\n\n  onclose?: () => void;\n  onmessage?: (value: string) => void;\n\n  constructor(\n    pipeWrite: NodeJS.WritableStream,\n    pipeRead: NodeJS.ReadableStream\n  ) {\n    this.#pipeWrite = pipeWrite;\n    const pipeReadEmitter = this.#subscriptions.use(\n      // NodeJS event emitters don't support `*` so we need to typecast\n      // As long as we don't use it we should be OK.\n      new EventEmitter(pipeRead as unknown as EventEmitter<Record<string, any>>)\n    );\n    pipeReadEmitter.on('data', (buffer: Buffer) => {\n      return this.#dispatch(buffer);\n    });\n    pipeReadEmitter.on('close', () => {\n      if (this.onclose) {\n        this.onclose.call(null);\n      }\n    });\n    pipeReadEmitter.on('error', debugError);\n    const pipeWriteEmitter = this.#subscriptions.use(\n      // NodeJS event emitters don't support `*` so we need to typecast\n      // As long as we don't use it we should be OK.\n      new EventEmitter(pipeRead as unknown as EventEmitter<Record<string, any>>)\n    );\n    pipeWriteEmitter.on('error', debugError);\n  }\n\n  send(message: string): void {\n    assert(!this.#isClosed, '`PipeTransport` is closed.');\n\n    this.#pipeWrite.write(message);\n    this.#pipeWrite.write('\\0');\n  }\n\n  #dispatch(buffer: Buffer): void {\n    assert(!this.#isClosed, '`PipeTransport` is closed.');\n\n    let end = buffer.indexOf('\\0');\n    if (end === -1) {\n      this.#pendingMessage += buffer.toString();\n      return;\n    }\n    const message = this.#pendingMessage + buffer.toString(undefined, 0, end);\n    if (this.onmessage) {\n      this.onmessage.call(null, message);\n    }\n\n    let start = end + 1;\n    end = buffer.indexOf('\\0', start);\n    while (end !== -1) {\n      if (this.onmessage) {\n        this.onmessage.call(null, buffer.toString(undefined, start, end));\n      }\n      start = end + 1;\n      end = buffer.indexOf('\\0', start);\n    }\n    this.#pendingMessage = buffer.toString(undefined, start);\n  }\n\n  close(): void {\n    this.#isClosed = true;\n    this.#subscriptions.dispose();\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}