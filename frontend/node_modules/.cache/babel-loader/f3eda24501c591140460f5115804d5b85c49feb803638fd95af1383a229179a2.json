{"ast":null,"code":"\"use strict\";\n\n/**\n * @license\n * Copyright 2023 Google Inc.\n * SPDX-License-Identifier: Apache-2.0\n */\nvar __addDisposableResource = this && this.__addDisposableResource || function (env, value, async) {\n  if (value !== null && value !== void 0) {\n    if (typeof value !== \"object\" && typeof value !== \"function\") throw new TypeError(\"Object expected.\");\n    var dispose;\n    if (async) {\n      if (!Symbol.asyncDispose) throw new TypeError(\"Symbol.asyncDispose is not defined.\");\n      dispose = value[Symbol.asyncDispose];\n    }\n    if (dispose === void 0) {\n      if (!Symbol.dispose) throw new TypeError(\"Symbol.dispose is not defined.\");\n      dispose = value[Symbol.dispose];\n    }\n    if (typeof dispose !== \"function\") throw new TypeError(\"Object not disposable.\");\n    env.stack.push({\n      value: value,\n      dispose: dispose,\n      async: async\n    });\n  } else if (async) {\n    env.stack.push({\n      async: true\n    });\n  }\n  return value;\n};\nvar __disposeResources = this && this.__disposeResources || function (SuppressedError) {\n  return function (env) {\n    function fail(e) {\n      env.error = env.hasError ? new SuppressedError(e, env.error, \"An error was suppressed during disposal.\") : e;\n      env.hasError = true;\n    }\n    function next() {\n      while (env.stack.length) {\n        var rec = env.stack.pop();\n        try {\n          var result = rec.dispose && rec.dispose.call(rec.value);\n          if (rec.async) return Promise.resolve(result).then(next, function (e) {\n            fail(e);\n            return next();\n          });\n        } catch (e) {\n          fail(e);\n        }\n      }\n      if (env.hasError) throw env.error;\n    }\n    return next();\n  };\n}(typeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\n  var e = new Error(message);\n  return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\n});\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.bubble = exports.guarded = exports.invokeAtMostOnceForArguments = exports.inertIfDisposed = exports.throwIfDisposed = exports.moveable = void 0;\nconst disposable_js_1 = require(\"./disposable.js\");\nconst Mutex_js_1 = require(\"./Mutex.js\");\nconst instances = new WeakSet();\nfunction moveable(Class, _) {\n  let hasDispose = false;\n  if (Class.prototype[disposable_js_1.disposeSymbol]) {\n    const dispose = Class.prototype[disposable_js_1.disposeSymbol];\n    Class.prototype[disposable_js_1.disposeSymbol] = function () {\n      if (instances.has(this)) {\n        instances.delete(this);\n        return;\n      }\n      return dispose.call(this);\n    };\n    hasDispose = true;\n  }\n  if (Class.prototype[disposable_js_1.asyncDisposeSymbol]) {\n    const asyncDispose = Class.prototype[disposable_js_1.asyncDisposeSymbol];\n    Class.prototype[disposable_js_1.asyncDisposeSymbol] = function () {\n      if (instances.has(this)) {\n        instances.delete(this);\n        return;\n      }\n      return asyncDispose.call(this);\n    };\n    hasDispose = true;\n  }\n  if (hasDispose) {\n    Class.prototype.move = function () {\n      instances.add(this);\n      return this;\n    };\n  }\n  return Class;\n}\nexports.moveable = moveable;\nfunction throwIfDisposed(message = value => {\n  return `Attempted to use disposed ${value.constructor.name}.`;\n}) {\n  return (target, _) => {\n    return function (...args) {\n      if (this.disposed) {\n        throw new Error(message(this));\n      }\n      return target.call(this, ...args);\n    };\n  };\n}\nexports.throwIfDisposed = throwIfDisposed;\nfunction inertIfDisposed(target, _) {\n  return function (...args) {\n    if (this.disposed) {\n      return;\n    }\n    return target.call(this, ...args);\n  };\n}\nexports.inertIfDisposed = inertIfDisposed;\n/**\n * The decorator only invokes the target if the target has not been invoked with\n * the same arguments before. The decorated method throws an error if it's\n * invoked with a different number of elements: if you decorate a method, it\n * should have the same number of arguments\n *\n * @internal\n */\nfunction invokeAtMostOnceForArguments(target, _) {\n  const cache = new WeakMap();\n  let cacheDepth = -1;\n  return function (...args) {\n    if (cacheDepth === -1) {\n      cacheDepth = args.length;\n    }\n    if (cacheDepth !== args.length) {\n      throw new Error('Memoized method was called with the wrong number of arguments');\n    }\n    let freshArguments = false;\n    let cacheIterator = cache;\n    for (const arg of args) {\n      if (cacheIterator.has(arg)) {\n        cacheIterator = cacheIterator.get(arg);\n      } else {\n        freshArguments = true;\n        cacheIterator.set(arg, new WeakMap());\n        cacheIterator = cacheIterator.get(arg);\n      }\n    }\n    if (!freshArguments) {\n      return;\n    }\n    return target.call(this, ...args);\n  };\n}\nexports.invokeAtMostOnceForArguments = invokeAtMostOnceForArguments;\nfunction guarded(getKey = function () {\n  return this;\n}) {\n  return (target, _) => {\n    const mutexes = new WeakMap();\n    return async function (...args) {\n      const env_1 = {\n        stack: [],\n        error: void 0,\n        hasError: false\n      };\n      try {\n        const key = getKey.call(this);\n        let mutex = mutexes.get(key);\n        if (!mutex) {\n          mutex = new Mutex_js_1.Mutex();\n          mutexes.set(key, mutex);\n        }\n        const _ = __addDisposableResource(env_1, await mutex.acquire(), true);\n        return await target.call(this, ...args);\n      } catch (e_1) {\n        env_1.error = e_1;\n        env_1.hasError = true;\n      } finally {\n        const result_1 = __disposeResources(env_1);\n        if (result_1) await result_1;\n      }\n    };\n  };\n}\nexports.guarded = guarded;\nconst bubbleHandlers = new WeakMap();\nconst bubbleInitializer = function (events) {\n  const handlers = bubbleHandlers.get(this) ?? new Map();\n  if (handlers.has(events)) {\n    return;\n  }\n  const handler = events !== undefined ? (type, event) => {\n    if (events.includes(type)) {\n      this.emit(type, event);\n    }\n  } : (type, event) => {\n    this.emit(type, event);\n  };\n  handlers.set(events, handler);\n  bubbleHandlers.set(this, handlers);\n};\n/**\n * Event emitter fields marked with `bubble` will have their events bubble up\n * the field owner.\n */\n// The type is too complicated to type.\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nfunction bubble(events) {\n  return ({\n    set,\n    get\n  }, context) => {\n    context.addInitializer(function () {\n      return bubbleInitializer.apply(this, [events]);\n    });\n    return {\n      set(emitter) {\n        const handler = bubbleHandlers.get(this).get(events);\n        // In case we are re-setting.\n        const oldEmitter = get.call(this);\n        if (oldEmitter !== undefined) {\n          oldEmitter.off('*', handler);\n        }\n        if (emitter === undefined) {\n          return;\n        }\n        emitter.on('*', handler);\n        set.call(this, emitter);\n      },\n      init(emitter) {\n        if (emitter === undefined) {\n          return emitter;\n        }\n        bubbleInitializer.apply(this, [events]);\n        const handler = bubbleHandlers.get(this).get(events);\n        emitter.on('*', handler);\n        return emitter;\n      }\n    };\n  };\n}\nexports.bubble = bubble;","map":{"version":3,"names":["disposable_js_1","require","Mutex_js_1","instances","WeakSet","moveable","Class","_","hasDispose","prototype","disposeSymbol","dispose","has","delete","call","asyncDisposeSymbol","asyncDispose","move","add","exports","throwIfDisposed","message","value","constructor","name","target","args","disposed","Error","inertIfDisposed","invokeAtMostOnceForArguments","cache","WeakMap","cacheDepth","length","freshArguments","cacheIterator","arg","get","set","guarded","getKey","mutexes","key","mutex","Mutex","__addDisposableResource","env_1","acquire","bubbleHandlers","bubbleInitializer","events","handlers","Map","handler","undefined","type","event","includes","emit","bubble","context","addInitializer","apply","emitter","oldEmitter","off","on","init"],"sources":["/Users/lawj4/webDevelopment/node_modules/puppeteer-core/src/util/decorators.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2023 Google Inc.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport type {EventType} from '../common/EventEmitter.js';\nimport type {EventEmitter} from '../common/EventEmitter.js';\nimport type {Disposed, Moveable} from '../common/types.js';\n\nimport {asyncDisposeSymbol, disposeSymbol} from './disposable.js';\nimport {Mutex} from './Mutex.js';\n\nconst instances = new WeakSet<object>();\n\nexport function moveable<\n  Class extends abstract new (...args: never[]) => Moveable,\n>(Class: Class, _: ClassDecoratorContext<Class>): Class {\n  let hasDispose = false;\n  if (Class.prototype[disposeSymbol]) {\n    const dispose = Class.prototype[disposeSymbol];\n    Class.prototype[disposeSymbol] = function (this: InstanceType<Class>) {\n      if (instances.has(this)) {\n        instances.delete(this);\n        return;\n      }\n      return dispose.call(this);\n    };\n    hasDispose = true;\n  }\n  if (Class.prototype[asyncDisposeSymbol]) {\n    const asyncDispose = Class.prototype[asyncDisposeSymbol];\n    Class.prototype[asyncDisposeSymbol] = function (this: InstanceType<Class>) {\n      if (instances.has(this)) {\n        instances.delete(this);\n        return;\n      }\n      return asyncDispose.call(this);\n    };\n    hasDispose = true;\n  }\n  if (hasDispose) {\n    Class.prototype.move = function (\n      this: InstanceType<Class>\n    ): InstanceType<Class> {\n      instances.add(this);\n      return this;\n    };\n  }\n  return Class;\n}\n\nexport function throwIfDisposed<This extends Disposed>(\n  message: (value: This) => string = value => {\n    return `Attempted to use disposed ${value.constructor.name}.`;\n  }\n) {\n  return (target: (this: This, ...args: any[]) => any, _: unknown) => {\n    return function (this: This, ...args: any[]): any {\n      if (this.disposed) {\n        throw new Error(message(this));\n      }\n      return target.call(this, ...args);\n    };\n  };\n}\n\nexport function inertIfDisposed<This extends Disposed>(\n  target: (this: This, ...args: any[]) => any,\n  _: unknown\n) {\n  return function (this: This, ...args: any[]): any {\n    if (this.disposed) {\n      return;\n    }\n    return target.call(this, ...args);\n  };\n}\n\n/**\n * The decorator only invokes the target if the target has not been invoked with\n * the same arguments before. The decorated method throws an error if it's\n * invoked with a different number of elements: if you decorate a method, it\n * should have the same number of arguments\n *\n * @internal\n */\nexport function invokeAtMostOnceForArguments(\n  target: (this: unknown, ...args: any[]) => any,\n  _: unknown\n): typeof target {\n  const cache = new WeakMap();\n  let cacheDepth = -1;\n  return function (this: unknown, ...args: unknown[]) {\n    if (cacheDepth === -1) {\n      cacheDepth = args.length;\n    }\n    if (cacheDepth !== args.length) {\n      throw new Error(\n        'Memoized method was called with the wrong number of arguments'\n      );\n    }\n    let freshArguments = false;\n    let cacheIterator = cache;\n    for (const arg of args) {\n      if (cacheIterator.has(arg as object)) {\n        cacheIterator = cacheIterator.get(arg as object)!;\n      } else {\n        freshArguments = true;\n        cacheIterator.set(arg as object, new WeakMap());\n        cacheIterator = cacheIterator.get(arg as object)!;\n      }\n    }\n    if (!freshArguments) {\n      return;\n    }\n    return target.call(this, ...args);\n  };\n}\n\nexport function guarded<T extends object>(\n  getKey = function (this: T): object {\n    return this;\n  }\n) {\n  return (\n    target: (this: T, ...args: any[]) => Promise<any>,\n    _: ClassMethodDecoratorContext<T>\n  ): typeof target => {\n    const mutexes = new WeakMap<object, Mutex>();\n    return async function (...args) {\n      const key = getKey.call(this);\n      let mutex = mutexes.get(key);\n      if (!mutex) {\n        mutex = new Mutex();\n        mutexes.set(key, mutex);\n      }\n      await using _ = await mutex.acquire();\n      return await target.call(this, ...args);\n    };\n  };\n}\n\nconst bubbleHandlers = new WeakMap<object, Map<any, any>>();\nconst bubbleInitializer = function <\n  T extends EventType[],\n  This extends EventEmitter<any>,\n>(this: This, events?: T) {\n  const handlers = bubbleHandlers.get(this) ?? new Map();\n  if (handlers.has(events)) {\n    return;\n  }\n\n  const handler =\n    events !== undefined\n      ? (type: EventType, event: unknown) => {\n          if (events.includes(type)) {\n            this.emit(type, event);\n          }\n        }\n      : (type: EventType, event: unknown) => {\n          this.emit(type, event);\n        };\n\n  handlers.set(events, handler);\n  bubbleHandlers.set(this, handlers);\n};\n/**\n * Event emitter fields marked with `bubble` will have their events bubble up\n * the field owner.\n */\n// The type is too complicated to type.\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nexport function bubble<T extends EventType[]>(events?: T) {\n  return <This extends EventEmitter<any>, Value extends EventEmitter<any>>(\n    {set, get}: ClassAccessorDecoratorTarget<This, Value>,\n    context: ClassAccessorDecoratorContext<This, Value>\n  ): ClassAccessorDecoratorResult<This, Value> => {\n    context.addInitializer(function () {\n      return bubbleInitializer.apply(this, [events]);\n    });\n    return {\n      set(emitter) {\n        const handler = bubbleHandlers.get(this)!.get(events)!;\n\n        // In case we are re-setting.\n        const oldEmitter = get.call(this);\n        if (oldEmitter !== undefined) {\n          oldEmitter.off('*', handler);\n        }\n\n        if (emitter === undefined) {\n          return;\n        }\n        emitter.on('*', handler);\n        set.call(this, emitter);\n      },\n      init(emitter) {\n        if (emitter === undefined) {\n          return emitter;\n        }\n\n        bubbleInitializer.apply(this, [events]);\n\n        const handler = bubbleHandlers.get(this)!.get(events)!;\n        emitter.on('*', handler as any);\n        return emitter;\n      },\n    };\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}