{"ast":null,"code":"\"use strict\";\n\n/**\n * @license\n * Copyright 2019 Google Inc.\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.IsolatedWorld = void 0;\nconst rxjs_js_1 = require(\"../../third_party/rxjs/rxjs.js\");\nconst Realm_js_1 = require(\"../api/Realm.js\");\nconst EventEmitter_js_1 = require(\"../common/EventEmitter.js\");\nconst util_js_1 = require(\"../common/util.js\");\nconst disposable_js_1 = require(\"../util/disposable.js\");\nconst ElementHandle_js_1 = require(\"./ElementHandle.js\");\nconst JSHandle_js_1 = require(\"./JSHandle.js\");\n/**\n * @internal\n */\nclass IsolatedWorld extends Realm_js_1.Realm {\n  #context;\n  #emitter = new EventEmitter_js_1.EventEmitter();\n  #frameOrWorker;\n  constructor(frameOrWorker, timeoutSettings) {\n    super(timeoutSettings);\n    this.#frameOrWorker = frameOrWorker;\n  }\n  get environment() {\n    return this.#frameOrWorker;\n  }\n  get client() {\n    return this.#frameOrWorker.client;\n  }\n  get emitter() {\n    return this.#emitter;\n  }\n  setContext(context) {\n    this.#context?.[disposable_js_1.disposeSymbol]();\n    context.once('disposed', this.#onContextDisposed.bind(this));\n    context.on('consoleapicalled', this.#onContextConsoleApiCalled.bind(this));\n    context.on('bindingcalled', this.#onContextBindingCalled.bind(this));\n    this.#context = context;\n    this.#emitter.emit('context', context);\n    void this.taskManager.rerunAll();\n  }\n  #onContextDisposed() {\n    this.#context = undefined;\n    if ('clearDocumentHandle' in this.#frameOrWorker) {\n      this.#frameOrWorker.clearDocumentHandle();\n    }\n  }\n  #onContextConsoleApiCalled(event) {\n    this.#emitter.emit('consoleapicalled', event);\n  }\n  #onContextBindingCalled(event) {\n    this.#emitter.emit('bindingcalled', event);\n  }\n  hasContext() {\n    return !!this.#context;\n  }\n  get context() {\n    return this.#context;\n  }\n  #executionContext() {\n    if (this.disposed) {\n      throw new Error(`Execution context is not available in detached frame or worker \"${this.environment.url()}\" (are you trying to evaluate?)`);\n    }\n    return this.#context;\n  }\n  /**\n   * Waits for the next context to be set on the isolated world.\n   */\n  async #waitForExecutionContext() {\n    const result = await (0, rxjs_js_1.firstValueFrom)((0, util_js_1.fromEmitterEvent)(this.#emitter, 'context').pipe((0, rxjs_js_1.raceWith)((0, util_js_1.fromEmitterEvent)(this.#emitter, 'disposed').pipe((0, rxjs_js_1.map)(() => {\n      // The message has to match the CDP message expected by the WaitTask class.\n      throw new Error('Execution context was destroyed');\n    })), (0, util_js_1.timeout)(this.timeoutSettings.timeout()))));\n    return result;\n  }\n  async evaluateHandle(pageFunction, ...args) {\n    pageFunction = (0, util_js_1.withSourcePuppeteerURLIfNone)(this.evaluateHandle.name, pageFunction);\n    // This code needs to schedule evaluateHandle call synchroniously (at\n    // least when the context is there) so we cannot unconditionally\n    // await.\n    let context = this.#executionContext();\n    if (!context) {\n      context = await this.#waitForExecutionContext();\n    }\n    return await context.evaluateHandle(pageFunction, ...args);\n  }\n  async evaluate(pageFunction, ...args) {\n    pageFunction = (0, util_js_1.withSourcePuppeteerURLIfNone)(this.evaluate.name, pageFunction);\n    // This code needs to schedule evaluate call synchroniously (at\n    // least when the context is there) so we cannot unconditionally\n    // await.\n    let context = this.#executionContext();\n    if (!context) {\n      context = await this.#waitForExecutionContext();\n    }\n    return await context.evaluate(pageFunction, ...args);\n  }\n  async adoptBackendNode(backendNodeId) {\n    // This code needs to schedule resolveNode call synchroniously (at\n    // least when the context is there) so we cannot unconditionally\n    // await.\n    let context = this.#executionContext();\n    if (!context) {\n      context = await this.#waitForExecutionContext();\n    }\n    const {\n      object\n    } = await this.client.send('DOM.resolveNode', {\n      backendNodeId: backendNodeId,\n      executionContextId: context.id\n    });\n    return this.createCdpHandle(object);\n  }\n  async adoptHandle(handle) {\n    if (handle.realm === this) {\n      // If the context has already adopted this handle, clone it so downstream\n      // disposal doesn't become an issue.\n      return await handle.evaluateHandle(value => {\n        return value;\n      });\n    }\n    const nodeInfo = await this.client.send('DOM.describeNode', {\n      objectId: handle.id\n    });\n    return await this.adoptBackendNode(nodeInfo.node.backendNodeId);\n  }\n  async transferHandle(handle) {\n    if (handle.realm === this) {\n      return handle;\n    }\n    // Implies it's a primitive value, probably.\n    if (handle.remoteObject().objectId === undefined) {\n      return handle;\n    }\n    const info = await this.client.send('DOM.describeNode', {\n      objectId: handle.remoteObject().objectId\n    });\n    const newHandle = await this.adoptBackendNode(info.node.backendNodeId);\n    await handle.dispose();\n    return newHandle;\n  }\n  /**\n   * @internal\n   */\n  createCdpHandle(remoteObject) {\n    if (remoteObject.subtype === 'node') {\n      return new ElementHandle_js_1.CdpElementHandle(this, remoteObject);\n    }\n    return new JSHandle_js_1.CdpJSHandle(this, remoteObject);\n  }\n  [disposable_js_1.disposeSymbol]() {\n    this.#context?.[disposable_js_1.disposeSymbol]();\n    this.#emitter.emit('disposed', undefined);\n    super[disposable_js_1.disposeSymbol]();\n    this.#emitter.removeAllListeners();\n  }\n}\nexports.IsolatedWorld = IsolatedWorld;","map":{"version":3,"names":["rxjs_js_1","require","Realm_js_1","EventEmitter_js_1","util_js_1","disposable_js_1","ElementHandle_js_1","JSHandle_js_1","IsolatedWorld","Realm","context","emitter","EventEmitter","frameOrWorker","constructor","timeoutSettings","environment","client","setContext","disposeSymbol","once","onContextDisposed","bind","on","onContextConsoleApiCalled","onContextBindingCalled","emit","taskManager","rerunAll","#onContextDisposed","undefined","clearDocumentHandle","#onContextConsoleApiCalled","event","#onContextBindingCalled","hasContext","executionContext","#executionContext","disposed","Error","url","waitForExecutionContext","#waitForExecutionContext","result","firstValueFrom","fromEmitterEvent","pipe","raceWith","map","timeout","evaluateHandle","pageFunction","args","withSourcePuppeteerURLIfNone","name","evaluate","adoptBackendNode","backendNodeId","object","send","executionContextId","id","createCdpHandle","adoptHandle","handle","realm","value","nodeInfo","objectId","node","transferHandle","remoteObject","info","newHandle","dispose","subtype","CdpElementHandle","CdpJSHandle","removeAllListeners","exports"],"sources":["/Users/lawj4/webDevelopment/Todo-List/frontend/node_modules/puppeteer-core/src/cdp/IsolatedWorld.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2019 Google Inc.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport type {Protocol} from 'devtools-protocol';\n\nimport {firstValueFrom, map, raceWith} from '../../third_party/rxjs/rxjs.js';\nimport type {CDPSession} from '../api/CDPSession.js';\nimport type {ElementHandle} from '../api/ElementHandle.js';\nimport type {JSHandle} from '../api/JSHandle.js';\nimport {Realm} from '../api/Realm.js';\nimport {EventEmitter} from '../common/EventEmitter.js';\nimport type {TimeoutSettings} from '../common/TimeoutSettings.js';\nimport type {EvaluateFunc, HandleFor} from '../common/types.js';\nimport {\n  fromEmitterEvent,\n  timeout,\n  withSourcePuppeteerURLIfNone,\n} from '../common/util.js';\nimport {disposeSymbol} from '../util/disposable.js';\n\nimport {CdpElementHandle} from './ElementHandle.js';\nimport type {ExecutionContext} from './ExecutionContext.js';\nimport type {CdpFrame} from './Frame.js';\nimport type {MAIN_WORLD, PUPPETEER_WORLD} from './IsolatedWorlds.js';\nimport {CdpJSHandle} from './JSHandle.js';\nimport type {CdpWebWorker} from './WebWorker.js';\n\n/**\n * @internal\n */\nexport interface PageBinding {\n  name: string;\n  pptrFunction: Function;\n}\n\n/**\n * @internal\n */\nexport interface IsolatedWorldChart {\n  [key: string]: IsolatedWorld;\n  [MAIN_WORLD]: IsolatedWorld;\n  [PUPPETEER_WORLD]: IsolatedWorld;\n}\n\n/**\n * @internal\n */\ntype IsolatedWorldEmitter = EventEmitter<{\n  // Emitted when the isolated world gets a new execution context.\n  context: ExecutionContext;\n  // Emitted when the isolated world is disposed.\n  disposed: undefined;\n  // Emitted when a new console message is logged.\n  consoleapicalled: Protocol.Runtime.ConsoleAPICalledEvent;\n  /** Emitted when a binding that is not installed by the ExecutionContext is called. */\n  bindingcalled: Protocol.Runtime.BindingCalledEvent;\n}>;\n\n/**\n * @internal\n */\nexport class IsolatedWorld extends Realm {\n  #context?: ExecutionContext;\n  #emitter: IsolatedWorldEmitter = new EventEmitter();\n\n  readonly #frameOrWorker: CdpFrame | CdpWebWorker;\n\n  constructor(\n    frameOrWorker: CdpFrame | CdpWebWorker,\n    timeoutSettings: TimeoutSettings\n  ) {\n    super(timeoutSettings);\n    this.#frameOrWorker = frameOrWorker;\n  }\n\n  get environment(): CdpFrame | CdpWebWorker {\n    return this.#frameOrWorker;\n  }\n\n  get client(): CDPSession {\n    return this.#frameOrWorker.client;\n  }\n\n  get emitter(): IsolatedWorldEmitter {\n    return this.#emitter;\n  }\n\n  setContext(context: ExecutionContext): void {\n    this.#context?.[disposeSymbol]();\n    context.once('disposed', this.#onContextDisposed.bind(this));\n    context.on('consoleapicalled', this.#onContextConsoleApiCalled.bind(this));\n    context.on('bindingcalled', this.#onContextBindingCalled.bind(this));\n    this.#context = context;\n    this.#emitter.emit('context', context);\n    void this.taskManager.rerunAll();\n  }\n\n  #onContextDisposed(): void {\n    this.#context = undefined;\n    if ('clearDocumentHandle' in this.#frameOrWorker) {\n      this.#frameOrWorker.clearDocumentHandle();\n    }\n  }\n\n  #onContextConsoleApiCalled(\n    event: Protocol.Runtime.ConsoleAPICalledEvent\n  ): void {\n    this.#emitter.emit('consoleapicalled', event);\n  }\n\n  #onContextBindingCalled(event: Protocol.Runtime.BindingCalledEvent): void {\n    this.#emitter.emit('bindingcalled', event);\n  }\n\n  hasContext(): boolean {\n    return !!this.#context;\n  }\n\n  get context(): ExecutionContext | undefined {\n    return this.#context;\n  }\n\n  #executionContext(): ExecutionContext | undefined {\n    if (this.disposed) {\n      throw new Error(\n        `Execution context is not available in detached frame or worker \"${this.environment.url()}\" (are you trying to evaluate?)`\n      );\n    }\n    return this.#context;\n  }\n\n  /**\n   * Waits for the next context to be set on the isolated world.\n   */\n  async #waitForExecutionContext(): Promise<ExecutionContext> {\n    const result = await firstValueFrom(\n      fromEmitterEvent(this.#emitter, 'context').pipe(\n        raceWith(\n          fromEmitterEvent(this.#emitter, 'disposed').pipe(\n            map(() => {\n              // The message has to match the CDP message expected by the WaitTask class.\n              throw new Error('Execution context was destroyed');\n            })\n          ),\n          timeout(this.timeoutSettings.timeout())\n        )\n      )\n    );\n    return result;\n  }\n\n  async evaluateHandle<\n    Params extends unknown[],\n    Func extends EvaluateFunc<Params> = EvaluateFunc<Params>,\n  >(\n    pageFunction: Func | string,\n    ...args: Params\n  ): Promise<HandleFor<Awaited<ReturnType<Func>>>> {\n    pageFunction = withSourcePuppeteerURLIfNone(\n      this.evaluateHandle.name,\n      pageFunction\n    );\n    // This code needs to schedule evaluateHandle call synchroniously (at\n    // least when the context is there) so we cannot unconditionally\n    // await.\n    let context = this.#executionContext();\n    if (!context) {\n      context = await this.#waitForExecutionContext();\n    }\n    return await context.evaluateHandle(pageFunction, ...args);\n  }\n\n  async evaluate<\n    Params extends unknown[],\n    Func extends EvaluateFunc<Params> = EvaluateFunc<Params>,\n  >(\n    pageFunction: Func | string,\n    ...args: Params\n  ): Promise<Awaited<ReturnType<Func>>> {\n    pageFunction = withSourcePuppeteerURLIfNone(\n      this.evaluate.name,\n      pageFunction\n    );\n    // This code needs to schedule evaluate call synchroniously (at\n    // least when the context is there) so we cannot unconditionally\n    // await.\n    let context = this.#executionContext();\n    if (!context) {\n      context = await this.#waitForExecutionContext();\n    }\n    return await context.evaluate(pageFunction, ...args);\n  }\n\n  override async adoptBackendNode(\n    backendNodeId?: Protocol.DOM.BackendNodeId\n  ): Promise<JSHandle<Node>> {\n    // This code needs to schedule resolveNode call synchroniously (at\n    // least when the context is there) so we cannot unconditionally\n    // await.\n    let context = this.#executionContext();\n    if (!context) {\n      context = await this.#waitForExecutionContext();\n    }\n    const {object} = await this.client.send('DOM.resolveNode', {\n      backendNodeId: backendNodeId,\n      executionContextId: context.id,\n    });\n    return this.createCdpHandle(object) as JSHandle<Node>;\n  }\n\n  async adoptHandle<T extends JSHandle<Node>>(handle: T): Promise<T> {\n    if (handle.realm === this) {\n      // If the context has already adopted this handle, clone it so downstream\n      // disposal doesn't become an issue.\n      return (await handle.evaluateHandle(value => {\n        return value;\n      })) as unknown as T;\n    }\n    const nodeInfo = await this.client.send('DOM.describeNode', {\n      objectId: handle.id,\n    });\n    return (await this.adoptBackendNode(nodeInfo.node.backendNodeId)) as T;\n  }\n\n  async transferHandle<T extends JSHandle<Node>>(handle: T): Promise<T> {\n    if (handle.realm === this) {\n      return handle;\n    }\n    // Implies it's a primitive value, probably.\n    if (handle.remoteObject().objectId === undefined) {\n      return handle;\n    }\n    const info = await this.client.send('DOM.describeNode', {\n      objectId: handle.remoteObject().objectId,\n    });\n    const newHandle = (await this.adoptBackendNode(\n      info.node.backendNodeId\n    )) as T;\n    await handle.dispose();\n    return newHandle;\n  }\n\n  /**\n   * @internal\n   */\n  createCdpHandle(\n    remoteObject: Protocol.Runtime.RemoteObject\n  ): JSHandle | ElementHandle<Node> {\n    if (remoteObject.subtype === 'node') {\n      return new CdpElementHandle(this, remoteObject);\n    }\n    return new CdpJSHandle(this, remoteObject);\n  }\n\n  [disposeSymbol](): void {\n    this.#context?.[disposeSymbol]();\n    this.#emitter.emit('disposed', undefined);\n    super[disposeSymbol]();\n    this.#emitter.removeAllListeners();\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}