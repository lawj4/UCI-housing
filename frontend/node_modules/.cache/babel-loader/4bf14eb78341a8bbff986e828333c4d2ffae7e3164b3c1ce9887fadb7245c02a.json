{"ast":null,"code":"\"use strict\";\n\n/**\n * @license\n * Copyright 2017 Google Inc.\n * SPDX-License-Identifier: Apache-2.0\n */\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.canDownload = exports.getInstalledBrowsers = exports.uninstall = exports.install = void 0;\nconst assert_1 = __importDefault(require(\"assert\"));\nconst child_process_1 = require(\"child_process\");\nconst fs_1 = require(\"fs\");\nconst promises_1 = require(\"fs/promises\");\nconst os_1 = __importDefault(require(\"os\"));\nconst path_1 = __importDefault(require(\"path\"));\nconst browser_data_js_1 = require(\"./browser-data/browser-data.js\");\nconst Cache_js_1 = require(\"./Cache.js\");\nconst debug_js_1 = require(\"./debug.js\");\nconst detectPlatform_js_1 = require(\"./detectPlatform.js\");\nconst fileUtil_js_1 = require(\"./fileUtil.js\");\nconst httpUtil_js_1 = require(\"./httpUtil.js\");\nconst debugInstall = (0, debug_js_1.debug)('puppeteer:browsers:install');\nconst times = new Map();\nfunction debugTime(label) {\n  times.set(label, process.hrtime());\n}\nfunction debugTimeEnd(label) {\n  const end = process.hrtime();\n  const start = times.get(label);\n  if (!start) {\n    return;\n  }\n  const duration = end[0] * 1000 + end[1] / 1e6 - (start[0] * 1000 + start[1] / 1e6); // calculate duration in milliseconds\n  debugInstall(`Duration for ${label}: ${duration}ms`);\n}\nasync function install(options) {\n  options.platform ??= (0, detectPlatform_js_1.detectBrowserPlatform)();\n  options.unpack ??= true;\n  if (!options.platform) {\n    throw new Error(`Cannot download a binary for the provided platform: ${os_1.default.platform()} (${os_1.default.arch()})`);\n  }\n  const url = getDownloadUrl(options.browser, options.platform, options.buildId, options.baseUrl);\n  try {\n    return await installUrl(url, options);\n  } catch (err) {\n    // If custom baseUrl is provided, do not fall back to CfT dashboard.\n    if (options.baseUrl && !options.forceFallbackForTesting) {\n      throw err;\n    }\n    debugInstall(`Error downloading from ${url}.`);\n    switch (options.browser) {\n      case browser_data_js_1.Browser.CHROME:\n      case browser_data_js_1.Browser.CHROMEDRIVER:\n      case browser_data_js_1.Browser.CHROMEHEADLESSSHELL:\n        {\n          debugInstall(`Trying to find download URL via https://googlechromelabs.github.io/chrome-for-testing.`);\n          const version = await (0, httpUtil_js_1.getJSON)(new URL(`https://googlechromelabs.github.io/chrome-for-testing/${options.buildId}.json`));\n          let platform = '';\n          switch (options.platform) {\n            case browser_data_js_1.BrowserPlatform.LINUX:\n              platform = 'linux64';\n              break;\n            case browser_data_js_1.BrowserPlatform.MAC_ARM:\n              platform = 'mac-arm64';\n              break;\n            case browser_data_js_1.BrowserPlatform.MAC:\n              platform = 'mac-x64';\n              break;\n            case browser_data_js_1.BrowserPlatform.WIN32:\n              platform = 'win32';\n              break;\n            case browser_data_js_1.BrowserPlatform.WIN64:\n              platform = 'win64';\n              break;\n          }\n          const url = version.downloads[options.browser]?.find(link => {\n            return link['platform'] === platform;\n          })?.url;\n          if (url) {\n            debugInstall(`Falling back to downloading from ${url}.`);\n            return await installUrl(new URL(url), options);\n          }\n          throw err;\n        }\n      default:\n        throw err;\n    }\n  }\n}\nexports.install = install;\nasync function installUrl(url, options) {\n  options.platform ??= (0, detectPlatform_js_1.detectBrowserPlatform)();\n  if (!options.platform) {\n    throw new Error(`Cannot download a binary for the provided platform: ${os_1.default.platform()} (${os_1.default.arch()})`);\n  }\n  const fileName = url.toString().split('/').pop();\n  (0, assert_1.default)(fileName, `A malformed download URL was found: ${url}.`);\n  const cache = new Cache_js_1.Cache(options.cacheDir);\n  const browserRoot = cache.browserRoot(options.browser);\n  const archivePath = path_1.default.join(browserRoot, `${options.buildId}-${fileName}`);\n  if (!(0, fs_1.existsSync)(browserRoot)) {\n    await (0, promises_1.mkdir)(browserRoot, {\n      recursive: true\n    });\n  }\n  if (!options.unpack) {\n    if ((0, fs_1.existsSync)(archivePath)) {\n      return archivePath;\n    }\n    debugInstall(`Downloading binary from ${url}`);\n    debugTime('download');\n    await (0, httpUtil_js_1.downloadFile)(url, archivePath, options.downloadProgressCallback);\n    debugTimeEnd('download');\n    return archivePath;\n  }\n  const outputPath = cache.installationDir(options.browser, options.platform, options.buildId);\n  try {\n    if ((0, fs_1.existsSync)(outputPath)) {\n      const installedBrowser = new Cache_js_1.InstalledBrowser(cache, options.browser, options.buildId, options.platform);\n      if (!(0, fs_1.existsSync)(installedBrowser.executablePath)) {\n        throw new Error(`The browser folder (${outputPath}) exists but the executable (${installedBrowser.executablePath}) is missing`);\n      }\n      await runSetup(installedBrowser);\n      return installedBrowser;\n    }\n    debugInstall(`Downloading binary from ${url}`);\n    try {\n      debugTime('download');\n      await (0, httpUtil_js_1.downloadFile)(url, archivePath, options.downloadProgressCallback);\n    } finally {\n      debugTimeEnd('download');\n    }\n    debugInstall(`Installing ${archivePath} to ${outputPath}`);\n    try {\n      debugTime('extract');\n      await (0, fileUtil_js_1.unpackArchive)(archivePath, outputPath);\n    } finally {\n      debugTimeEnd('extract');\n    }\n    const installedBrowser = new Cache_js_1.InstalledBrowser(cache, options.browser, options.buildId, options.platform);\n    if (options.buildIdAlias) {\n      const metadata = installedBrowser.readMetadata();\n      metadata.aliases[options.buildIdAlias] = options.buildId;\n      installedBrowser.writeMetadata(metadata);\n    }\n    await runSetup(installedBrowser);\n    return installedBrowser;\n  } finally {\n    if ((0, fs_1.existsSync)(archivePath)) {\n      await (0, promises_1.unlink)(archivePath);\n    }\n  }\n}\nasync function runSetup(installedBrowser) {\n  // On Windows for Chrome invoke setup.exe to configure sandboxes.\n  if ((installedBrowser.platform === browser_data_js_1.BrowserPlatform.WIN32 || installedBrowser.platform === browser_data_js_1.BrowserPlatform.WIN64) && installedBrowser.browser === browser_data_js_1.Browser.CHROME && installedBrowser.platform === (0, detectPlatform_js_1.detectBrowserPlatform)()) {\n    try {\n      debugTime('permissions');\n      const browserDir = path_1.default.dirname(installedBrowser.executablePath);\n      const setupExePath = path_1.default.join(browserDir, 'setup.exe');\n      if (!(0, fs_1.existsSync)(setupExePath)) {\n        return;\n      }\n      (0, child_process_1.spawnSync)(path_1.default.join(browserDir, 'setup.exe'), [`--configure-browser-in-directory=` + browserDir], {\n        shell: true\n      });\n      // TODO: Handle error here. Currently the setup.exe sometimes\n      // errors although it sets the permissions correctly.\n    } finally {\n      debugTimeEnd('permissions');\n    }\n  }\n}\n/**\n *\n * @public\n */\nasync function uninstall(options) {\n  options.platform ??= (0, detectPlatform_js_1.detectBrowserPlatform)();\n  if (!options.platform) {\n    throw new Error(`Cannot detect the browser platform for: ${os_1.default.platform()} (${os_1.default.arch()})`);\n  }\n  new Cache_js_1.Cache(options.cacheDir).uninstall(options.browser, options.platform, options.buildId);\n}\nexports.uninstall = uninstall;\n/**\n * Returns metadata about browsers installed in the cache directory.\n *\n * @public\n */\nasync function getInstalledBrowsers(options) {\n  return new Cache_js_1.Cache(options.cacheDir).getInstalledBrowsers();\n}\nexports.getInstalledBrowsers = getInstalledBrowsers;\n/**\n * @public\n */\nasync function canDownload(options) {\n  options.platform ??= (0, detectPlatform_js_1.detectBrowserPlatform)();\n  if (!options.platform) {\n    throw new Error(`Cannot download a binary for the provided platform: ${os_1.default.platform()} (${os_1.default.arch()})`);\n  }\n  return await (0, httpUtil_js_1.headHttpRequest)(getDownloadUrl(options.browser, options.platform, options.buildId, options.baseUrl));\n}\nexports.canDownload = canDownload;\nfunction getDownloadUrl(browser, platform, buildId, baseUrl) {\n  return new URL(browser_data_js_1.downloadUrls[browser](platform, buildId, baseUrl));\n}","map":{"version":3,"names":["assert_1","__importDefault","require","child_process_1","fs_1","promises_1","os_1","path_1","browser_data_js_1","Cache_js_1","debug_js_1","detectPlatform_js_1","fileUtil_js_1","httpUtil_js_1","debugInstall","debug","times","Map","debugTime","label","set","process","hrtime","debugTimeEnd","end","start","get","duration","install","options","platform","detectBrowserPlatform","unpack","Error","default","arch","url","getDownloadUrl","browser","buildId","baseUrl","installUrl","err","forceFallbackForTesting","Browser","CHROME","CHROMEDRIVER","CHROMEHEADLESSSHELL","version","getJSON","URL","BrowserPlatform","LINUX","MAC_ARM","MAC","WIN32","WIN64","downloads","find","link","exports","fileName","toString","split","pop","cache","Cache","cacheDir","browserRoot","archivePath","join","existsSync","mkdir","recursive","downloadFile","downloadProgressCallback","outputPath","installationDir","installedBrowser","InstalledBrowser","executablePath","runSetup","unpackArchive","buildIdAlias","metadata","readMetadata","aliases","writeMetadata","unlink","browserDir","dirname","setupExePath","spawnSync","shell","uninstall","getInstalledBrowsers","canDownload","headHttpRequest","downloadUrls"],"sources":["/Users/lawj4/webDevelopment/Todo-List/frontend/node_modules/@puppeteer/browsers/src/install.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2017 Google Inc.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport assert from 'assert';\nimport {spawnSync} from 'child_process';\nimport {existsSync} from 'fs';\nimport {mkdir, unlink} from 'fs/promises';\nimport os from 'os';\nimport path from 'path';\n\nimport {\n  Browser,\n  BrowserPlatform,\n  downloadUrls,\n} from './browser-data/browser-data.js';\nimport {Cache, InstalledBrowser} from './Cache.js';\nimport {debug} from './debug.js';\nimport {detectBrowserPlatform} from './detectPlatform.js';\nimport {unpackArchive} from './fileUtil.js';\nimport {downloadFile, getJSON, headHttpRequest} from './httpUtil.js';\n\nconst debugInstall = debug('puppeteer:browsers:install');\n\nconst times = new Map<string, [number, number]>();\nfunction debugTime(label: string) {\n  times.set(label, process.hrtime());\n}\n\nfunction debugTimeEnd(label: string) {\n  const end = process.hrtime();\n  const start = times.get(label);\n  if (!start) {\n    return;\n  }\n  const duration =\n    end[0] * 1000 + end[1] / 1e6 - (start[0] * 1000 + start[1] / 1e6); // calculate duration in milliseconds\n  debugInstall(`Duration for ${label}: ${duration}ms`);\n}\n\n/**\n * @public\n */\nexport interface InstallOptions {\n  /**\n   * Determines the path to download browsers to.\n   */\n  cacheDir: string;\n  /**\n   * Determines which platform the browser will be suited for.\n   *\n   * @defaultValue **Auto-detected.**\n   */\n  platform?: BrowserPlatform;\n  /**\n   * Determines which browser to install.\n   */\n  browser: Browser;\n  /**\n   * Determines which buildId to download. BuildId should uniquely identify\n   * binaries and they are used for caching.\n   */\n  buildId: string;\n  /**\n   * An alias for the provided `buildId`. It will be used to maintain local\n   * metadata to support aliases in the `launch` command.\n   *\n   * @example 'canary'\n   */\n  buildIdAlias?: string;\n  /**\n   * Provides information about the progress of the download.\n   */\n  downloadProgressCallback?: (\n    downloadedBytes: number,\n    totalBytes: number\n  ) => void;\n  /**\n   * Determines the host that will be used for downloading.\n   *\n   * @defaultValue Either\n   *\n   * - https://storage.googleapis.com/chrome-for-testing-public or\n   * - https://archive.mozilla.org/pub/firefox/nightly/latest-mozilla-central\n   *\n   */\n  baseUrl?: string;\n  /**\n   * Whether to unpack and install browser archives.\n   *\n   * @defaultValue `true`\n   */\n  unpack?: boolean;\n  /**\n   * @internal\n   * @defaultValue `false`\n   */\n  forceFallbackForTesting?: boolean;\n}\n\n/**\n * @public\n */\nexport function install(\n  options: InstallOptions & {unpack?: true}\n): Promise<InstalledBrowser>;\n/**\n * @public\n */\nexport function install(\n  options: InstallOptions & {unpack: false}\n): Promise<string>;\nexport async function install(\n  options: InstallOptions\n): Promise<InstalledBrowser | string> {\n  options.platform ??= detectBrowserPlatform();\n  options.unpack ??= true;\n  if (!options.platform) {\n    throw new Error(\n      `Cannot download a binary for the provided platform: ${os.platform()} (${os.arch()})`\n    );\n  }\n  const url = getDownloadUrl(\n    options.browser,\n    options.platform,\n    options.buildId,\n    options.baseUrl\n  );\n  try {\n    return await installUrl(url, options);\n  } catch (err) {\n    // If custom baseUrl is provided, do not fall back to CfT dashboard.\n    if (options.baseUrl && !options.forceFallbackForTesting) {\n      throw err;\n    }\n    debugInstall(`Error downloading from ${url}.`);\n    switch (options.browser) {\n      case Browser.CHROME:\n      case Browser.CHROMEDRIVER:\n      case Browser.CHROMEHEADLESSSHELL: {\n        debugInstall(\n          `Trying to find download URL via https://googlechromelabs.github.io/chrome-for-testing.`\n        );\n        interface Version {\n          downloads: Record<string, Array<{platform: string; url: string}>>;\n        }\n        const version = (await getJSON(\n          new URL(\n            `https://googlechromelabs.github.io/chrome-for-testing/${options.buildId}.json`\n          )\n        )) as Version;\n        let platform = '';\n        switch (options.platform) {\n          case BrowserPlatform.LINUX:\n            platform = 'linux64';\n            break;\n          case BrowserPlatform.MAC_ARM:\n            platform = 'mac-arm64';\n            break;\n          case BrowserPlatform.MAC:\n            platform = 'mac-x64';\n            break;\n          case BrowserPlatform.WIN32:\n            platform = 'win32';\n            break;\n          case BrowserPlatform.WIN64:\n            platform = 'win64';\n            break;\n        }\n        const url = version.downloads[options.browser]?.find(link => {\n          return link['platform'] === platform;\n        })?.url;\n        if (url) {\n          debugInstall(`Falling back to downloading from ${url}.`);\n          return await installUrl(new URL(url), options);\n        }\n        throw err;\n      }\n      default:\n        throw err;\n    }\n  }\n}\n\nasync function installUrl(\n  url: URL,\n  options: InstallOptions\n): Promise<InstalledBrowser | string> {\n  options.platform ??= detectBrowserPlatform();\n  if (!options.platform) {\n    throw new Error(\n      `Cannot download a binary for the provided platform: ${os.platform()} (${os.arch()})`\n    );\n  }\n  const fileName = url.toString().split('/').pop();\n  assert(fileName, `A malformed download URL was found: ${url}.`);\n  const cache = new Cache(options.cacheDir);\n  const browserRoot = cache.browserRoot(options.browser);\n  const archivePath = path.join(browserRoot, `${options.buildId}-${fileName}`);\n  if (!existsSync(browserRoot)) {\n    await mkdir(browserRoot, {recursive: true});\n  }\n\n  if (!options.unpack) {\n    if (existsSync(archivePath)) {\n      return archivePath;\n    }\n    debugInstall(`Downloading binary from ${url}`);\n    debugTime('download');\n    await downloadFile(url, archivePath, options.downloadProgressCallback);\n    debugTimeEnd('download');\n    return archivePath;\n  }\n\n  const outputPath = cache.installationDir(\n    options.browser,\n    options.platform,\n    options.buildId\n  );\n\n  try {\n    if (existsSync(outputPath)) {\n      const installedBrowser = new InstalledBrowser(\n        cache,\n        options.browser,\n        options.buildId,\n        options.platform\n      );\n      if (!existsSync(installedBrowser.executablePath)) {\n        throw new Error(\n          `The browser folder (${outputPath}) exists but the executable (${installedBrowser.executablePath}) is missing`\n        );\n      }\n      await runSetup(installedBrowser);\n      return installedBrowser;\n    }\n    debugInstall(`Downloading binary from ${url}`);\n    try {\n      debugTime('download');\n      await downloadFile(url, archivePath, options.downloadProgressCallback);\n    } finally {\n      debugTimeEnd('download');\n    }\n\n    debugInstall(`Installing ${archivePath} to ${outputPath}`);\n    try {\n      debugTime('extract');\n      await unpackArchive(archivePath, outputPath);\n    } finally {\n      debugTimeEnd('extract');\n    }\n\n    const installedBrowser = new InstalledBrowser(\n      cache,\n      options.browser,\n      options.buildId,\n      options.platform\n    );\n    if (options.buildIdAlias) {\n      const metadata = installedBrowser.readMetadata();\n      metadata.aliases[options.buildIdAlias] = options.buildId;\n      installedBrowser.writeMetadata(metadata);\n    }\n\n    await runSetup(installedBrowser);\n    return installedBrowser;\n  } finally {\n    if (existsSync(archivePath)) {\n      await unlink(archivePath);\n    }\n  }\n}\n\nasync function runSetup(installedBrowser: InstalledBrowser): Promise<void> {\n  // On Windows for Chrome invoke setup.exe to configure sandboxes.\n  if (\n    (installedBrowser.platform === BrowserPlatform.WIN32 ||\n      installedBrowser.platform === BrowserPlatform.WIN64) &&\n    installedBrowser.browser === Browser.CHROME &&\n    installedBrowser.platform === detectBrowserPlatform()\n  ) {\n    try {\n      debugTime('permissions');\n      const browserDir = path.dirname(installedBrowser.executablePath);\n      const setupExePath = path.join(browserDir, 'setup.exe');\n      if (!existsSync(setupExePath)) {\n        return;\n      }\n      spawnSync(\n        path.join(browserDir, 'setup.exe'),\n        [`--configure-browser-in-directory=` + browserDir],\n        {\n          shell: true,\n        }\n      );\n      // TODO: Handle error here. Currently the setup.exe sometimes\n      // errors although it sets the permissions correctly.\n    } finally {\n      debugTimeEnd('permissions');\n    }\n  }\n}\n\n/**\n * @public\n */\nexport interface UninstallOptions {\n  /**\n   * Determines the platform for the browser binary.\n   *\n   * @defaultValue **Auto-detected.**\n   */\n  platform?: BrowserPlatform;\n  /**\n   * The path to the root of the cache directory.\n   */\n  cacheDir: string;\n  /**\n   * Determines which browser to uninstall.\n   */\n  browser: Browser;\n  /**\n   * The browser build to uninstall\n   */\n  buildId: string;\n}\n\n/**\n *\n * @public\n */\nexport async function uninstall(options: UninstallOptions): Promise<void> {\n  options.platform ??= detectBrowserPlatform();\n  if (!options.platform) {\n    throw new Error(\n      `Cannot detect the browser platform for: ${os.platform()} (${os.arch()})`\n    );\n  }\n\n  new Cache(options.cacheDir).uninstall(\n    options.browser,\n    options.platform,\n    options.buildId\n  );\n}\n\n/**\n * @public\n */\nexport interface GetInstalledBrowsersOptions {\n  /**\n   * The path to the root of the cache directory.\n   */\n  cacheDir: string;\n}\n\n/**\n * Returns metadata about browsers installed in the cache directory.\n *\n * @public\n */\nexport async function getInstalledBrowsers(\n  options: GetInstalledBrowsersOptions\n): Promise<InstalledBrowser[]> {\n  return new Cache(options.cacheDir).getInstalledBrowsers();\n}\n\n/**\n * @public\n */\nexport async function canDownload(options: InstallOptions): Promise<boolean> {\n  options.platform ??= detectBrowserPlatform();\n  if (!options.platform) {\n    throw new Error(\n      `Cannot download a binary for the provided platform: ${os.platform()} (${os.arch()})`\n    );\n  }\n  return await headHttpRequest(\n    getDownloadUrl(\n      options.browser,\n      options.platform,\n      options.buildId,\n      options.baseUrl\n    )\n  );\n}\n\nfunction getDownloadUrl(\n  browser: Browser,\n  platform: BrowserPlatform,\n  buildId: string,\n  baseUrl?: string\n): URL {\n  return new URL(downloadUrls[browser](platform, buildId, baseUrl));\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}